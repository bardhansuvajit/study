===================================================================================================
=================*************** üîß Core PHP & Language Concepts ***************===================
===================================================================================================

PHP
    Personal Home Page: Hypertext Preprocessor
    A preprocessor is Server-side engine that processes PHP code before outpu

PHP parser
    part of PHP inetrpreter, that reads PHP codes, breaks it (into Tokens), understand sturcture, then sends to interpreter/ compiler to execute

AST
    Abstract syntax tree, shows logical part of code. NOT what we typed, but what it means
    e.g. echo 2 + 3 >>> ECHO, ADD, NUMBER, 2, NUMBER, 3

== vs ===
    checks value vs checks value & type

Variable scoping
    Global: Declared outside functions.
    Local: Declared inside functions.
    Static: Retains value between function calls with static keyword.

inlcude || require
    error handling - gives warning if file not found (script execution continues) || gives fatal error (script execution stops)
    use case - file optional || file required

unset || unlink
    destroys variable || deletes file from filesystem

Call by Value || Call by Reference
    passes copy of the variable, keeping the original unchanged || passes the actual variable, allowing modification
    e.g. $a = 1; $b = $a; $b = 2; echo $a; > 1
    e.g. $a = 1; $b = &$a; $b = 2; echo $a; > 2

** ERROR TYPES
    notices     - non critical. user cant see these. e.g. undefined variable
    warnings    - important than notice. script execution is not interrupted. user can see. e.g. include() does not have a file
    syntax/ parsing error   - php parser is unable to execute. e.g. missing semicolon/ quote mark/ parenthesis
    fatal       - script execution immediately terminated. e.g. accessing non existing object property
to see errors in php.ini set, ini_set('display_errors', 1)
then include error_reporting(E_ALL) in all pages

MVC
    when user visits an url, https://example.com/products/show/1 > 
    router analyzes the URL & sends request to CONTROLLER
    CONTROLLER asks MODEL for data & handles request
    MODEL fetches data from DB
    then VIEW displays output

** Warning: Cannot modify header information - headers already sent ---- WHY THIS HAPPENS & HOW TO SOLVE ?
    in PHP, header(), setcookie(), session_start() must be called before any output sent to browser
        1 e.g.
        echo "Welcome!";
        header("Location: dashboard.php");  // ‚ùå Warning here
        2 e.g.
        ‚ê£<?php
        header("Location: login.php");  // ‚ùå Warning, There's a space before <?php on the first line
        3 e.g.
        include 'header.php';  // this might output HTML or whitespace
        header("Location: profile.php");  // ‚ùå Warning

    SOLUTION
        1. No output before header()
        2. Check for whitespace or blank lines
        3. Use output buffering, allows PHP to delay output until all headers are sent:
            <?php
                ob_start();  // Start output buffering
                header("Location: next.php");  // Safe even if there's echo after this
                ob_end_flush(); // Send output at the end
            ?>

$i = 016;
echo $i / 2; OUTPUT ?
    Numbers that start with 0 are interpreted as octal

Closure
    anonymous functions (function without name) to capture variable from its surrounding scope using the use keyword.
    e.g.
        $prefix = "Hi";
        $sayHello = function($name) use ($prefix) {
            return "$prefix, $name!";
        };
        echo $sayHello("Suvajit"); // Output: Hi, Suvajit!

isset() || empty() || is_null()
    isset() for existence check, empty() for blank checks, and is_null() for null-specific logic.

Garbage Collection
    manage memory by cleaning up unused objects or circular references that are no longer accessible.
    PROBLEM
        Variables in PHP keep track of how many references point to it. When variable is unset, the count decreses. If the reference count drops to zero, PHP frees the memory immediately. 
        But freeing up memory is not easy like this, MEMORY LEAK happens when 2 variables reference each other, even when unset, memory won't be free
    SOLUTION
        PHP solves this using a cyclic garbage collector, which:
            Detects circular references (When 2 variables reference each other, memory could never be free making Memory Leak)
            Uses "Root Buffer" to track possible cycles
            Periodically collects and frees them using gc_collect_cycles();
    Garbage Collection in PHP is automatic. But to tune performance we can manually manage
        gc_enable();             // Turn GC back on
        gc_disable();            // Turn GC off
        gc_collect_cycles();     // Force collection now
        gc_enabled();            // Check if it's on
        gc_status();             // See stats 

Magic Methods
    Special methods like __construct, __get, __set, __call, etc.
    They enable object lifecycle management, dynamic method/property access, and custom behavior (e.g., serialization, cloning).

How does PHP handle type juggling
    Type juggling is when PHP automatically converts a variable from one type to another depending on the context.
    PHP is a loosely typed/ dynamically typed language, means it performs type juggling (automatic type conversion) when different data types are involved in operations (Arithmetic/ Comparison operations)
    How to avoid ?
        Use strict comparison (===)
        declare(strict_types=1);

session management
    session is to store information accorss multiple pages on the server
    useful for User authentication (e.g., logged-in users) + Shopping carts + Flash messages + Form data retention
    HOW IT WORKS
        PHP creates a unique session ID
        That ID is sent to the user's browser as a cookie (default name: PHPSESSID)
        The browser sends the session ID back to the server with each request
        PHP uses the ID to fetch session data from server storage
    CREATE
        session_start();
        $_SESSION['username'] = 'suvajit';
        $_SESSION['is_logged_in'] = true;
        echo $_SESSION['username']; // Output: suvajit
        session_unset();    // Clear session variables
        session_destroy();  // Destroy the session


** Apache || Nginx
    They are web servers, handles HTTP requests. They serve static files, handle dynamic content, manage multiple users, log requests, manage redirects etc.

    DIFFERENCES
    Apache uses built-in PHP with mod_php || Nginx uses external PHP-FPM
    Static file speed average || Faster (Asynchronous)
    Process/thread-based architechture || Event-driven architechture
    Creates a new thread or process for each request || Uses a single-threaded, non-blocking architecture

Explain the lifecycle of a PHP request.
    üåê 1. User Sends a Request
        User opens a page > The browser sends an HTTP request to your server > Your web server (Apache or Nginx) receives the request.
    üß∞ 2. Web Server Handles the Request
        If it's a static file (like index.html, an image, or CSS), the server sends it directly.
        If it's a PHP file, the server forwards it to the PHP engine for processing.
    üåÄ 3. PHP Engine Takes Over
        The PHP engine (interpreter) begins executing the code in the file. This includes:
            Parsing the PHP script
            Running any logic (e.g., if, for, functions, etc.)
            Connecting to a database if needed
            Fetching or processing data (e.g., user input, APIs)
    üõ¢Ô∏è 4. Database Interaction (if needed)
        PHP sends a query to the database.
        The database responds with data.
        PHP stores the data and continues processing.
    üßæ 5. Generate Output
        Once logic is done, PHP produces output, usually HTML
    üì§ 6. Send the Response to the Browser
        It sends that back to the browser as an HTTP response.
    üîÅ 7. Clean Up & End
        PHP automatically cleans up memory and variables.
        Closes database connections (or garbage collects them).
        The request is complete.


What tools do you use for profiling and debugging PHP code?
    1. Xdebug (for Debugging)
        Inspect logic errors
        Debug API responses
        Profile slow pages
    2. XHProf / Tideways / Blackfire.io - For Profiling
        XHProf (Facebook) / Tideways
            Lightweight profiler
            Shows function call hierarchy
            Measures CPU time and memory usage
        Blackfire.io (Commercial, by Symfony creators)
            Advanced cloud-based profiler
            Visual timelines, flamegraphs, call graphs
            Integration with CI/CD
        Use these to spot bottlenecks and optimize slow parts of your app.
    3. Laravel Telescope
        Requests, sessions, exceptions, queries
        Queues, jobs, mail, notifications
        Model changes
    4. PHPUnit + Debugging Tools
        Use assert statements with test coverage
        Combine with Xdebug or coverage reports
    












==========================================================================================
=================*************** üß± OOP & Architecture ***************===================
==========================================================================================

Class & Object
    Class is a template/ blueprint of an object.
    Object is an example/ instance of a class.

PUBLIC & `this` keyword
    public is a visibility keyword. means the properties & methods can be access from anywhere
    this refers to current object. Used to access properties & methods inside class

Constructor & Destructor
    CONSTRUCTOR is a function that runs automatically when an instance of a class is created/ when an object is created
        Used to set initial values
    DESTRUCTOR is a function that runs automatically when an object is destroyed
        Used to close files/ DB connection

pillars of OOP. with Examples
    INHERITANCE (EXTENDS)
        access properties & methods (public & protected) from one class to another.
        class class2 extends class1 {...}
        * if there are constructor in both classes (parent & child), child class has higher priority. Same thing goes for when both have same method name.
        * parent::__construct() - When we use parent::__construct() inside a child class constructor, it calls the parent class's constructor. So both parent and child constructors run
        * parent::anotherMethod() - when parent & child classes have same name, only child class's method runs (Method Overriding) but if you want to run parent class's method, use this inside child class's method
        * :: -> Scope Resolution Operator - used to access class constants, static properties, and static methods, or refer to a parent class.
        * Method Overriding - When parent & child classes have same name & the method is called, the child version runs (Not the parent's)
        * Method Overloading - same method name with different number of arguments ‚Äî but PHP doesn't support this directly.
        * final keyword - Cannot Be Extended. used to prevent inheritance/ prevent method overriding. final class A {...} && final public function someFunction() {...}
    ENCAPSULATION (ACCESS MODIFIER, Getters & Setters)
        bundling similar data into a structured unit/ into a capsule format
        1. public       >> properties/ methods can be accessed inside/ outside of class scope. This is default
        2. protected    >> properties/ methods can be accessed inside of the class scope & its inherited classes
        3. private      >> properties/ methods can be accessed ONLY inside of the class scope
        EXAMPLE
            ‚ùå Without Encapsulation (Bad Practice):
            class BadBank { public $balance = 0; }
            $acc = new BadBank();
            $acc->balance = -9999; // ‚ùå no control, dangerous!

            ‚úÖ Example (Full):
            class BankAccount {
                private $balance = 0;
                public function deposit($amount) {
                    if ($amount > 0) { $this->balance += $amount; }
                }

                public function getBalance() { return $this->balance; }
            }

            $acc = new BankAccount();
            $acc->deposit(1000);
            echo $acc->getBalance(); // ‚úÖ 1000

        * Why Encapsulation - You decide what can be accessed or modified
        * Hiding internal state & behavior of an object, and only exposing controlled access via methods.
        * Internal logic can be changed without affecting others
    ABSTRACTION (Abstract class)
        Abstract means partial/ incomplete. Abstract class contains atleast one Abstract/ incomplete function (others maybe regular functions).
        EXAMPLE
            abstract class AbstractClass {
                abstract protected function func1($string);
            }
            class New1 extends AbstractClass {
                public function func1($string) {
                    return 'here: '.$string;
                }
            }
            $classNew = new New1();
            echo $classNew->func1('test name');
        * Why Incomplete ? because, abstract function must be declared but not called/ instantiated
        * Objects can not be created from an Abstract class
        * Inherited/ child class must contain abstract function
        * declared using the `abstract` keyword
        * Any class that extends an abstract class must either implement all of its abstract methods or itself be declared abstract
        * Abstract classes can also contain non-abstract (concrete) methods but must contain at leats one abstract method
        * Why Abstraction - when we need to define a common structure among different classes. 
    INTERFACE (interface, implements)
        used to ensure a class has certain methods & it supports multiple inheritance
        * Supports multiple inheritance
        * Interface can only contain abstract methods (no body functions), no regular methods and those function must also be called in 'inherited'/ 'child' class || Abstract classes can have regular methods
        * We cant define 'properties'/ 'variables' || Abstract classes can have
        * No 'Construct' inside interface
        * All methods must be 'public' || Abstract class methods can be 'public'/ 'protected'
        * Interface uses 'implements', Inheritance uses 'extends'
        * Objects cannot be made for interface

    ABSTRACTION vs INTERFACE
        single inheritance || mutiple inheritance
        can have regular methods || only abstract methods, no regular methods

    ENCAPSULATION vs ABSTRACTION
        way of protecting data || way of hiding unnecessary information
        process of containing information || process of obtaining information
        use access specifier || use interface & abstract class

SOLID principle
    acronym for 5 principles of object-oriented design.
    S - Single Responsibility Principle (SRP)
        A single class should have a single responsibility.
        e.g.
            class UserManager {
                public function createUser() { ... }
                public function sendWelcomeEmail() { ... } // Email logic doesn't belong here
            }
    O - Open/Closed Principle (OCP)
        Classes should be opened for extension (add new features by extending the existing code), closed for modification (dont change existing code that is already working)
        e.g.
            // ‚ùå Without OCP
            class Payment {
                public function pay($type, $amount) {
                    if ($type === 'paypal') {
                        // PayPal logic
                    } elseif ($type === 'stripe') {
                        // Stripe logic
                    }
                    // what if we add Razorpay? keep editing this üò´
                }
            }
            ‚úÖ With OCP ‚Äî Flexible Design Using Interface
            interface PaymentMethod {
                public function pay($amount);
            }
            class Paypal implements PaymentMethod {
                public function pay($amount) {
                    echo "Paying ‚Çπ$amount via PayPal";
                }
            }
            class Stripe implements PaymentMethod {
                public function pay($amount) {
                    echo "Paying ‚Çπ$amount via Stripe";
                }
            }
            // Now, if you want to add Razorpay:
            class Razorpay implements PaymentMethod {
                public function pay($amount) {
                    echo "Paying ‚Çπ$amount via Razorpay";
                }
            }
    L - Liskov Substitution Principle (LSP)
        Subclasses should be substitutable for their base classes. If class B is a subclass of A, you should be able to use B anywhere A is expected ‚Äî without breaking the app.
        e.g.
            class Bird {
                public function fly() {}
            }
            class Eagle extends Bird {
                public function fly() { echo \"Flying\"; }
            }
            ‚úÖ Eagle behaves like a Bird.
            ‚ùå If Penguin extends Bird but can't fly ‚Üí LSP is broken.
    I - Interface Segregation Principle (ISP)
        Clients shouldn't be forced to depend on methods they don't use. Prefer many small interfaces over one big one.
        e.g.
            ‚ùå Bad:
            interface Worker {
                public function work();
                public function eat();
            }
            ‚úÖ Good:
            interface Workable { public function work(); }
            interface Eatable { public function eat(); }

            class Human implements Workable, Eatable {}
            class Robot implements Workable {}

    D - Dependency Inversion Principle (DIP)
        Depend on abstractions, not concrete classes. Instead of hardcoding dependencies, rely on interfaces.
        e.g.
            ‚ùå Bad:
            class OrderService {
                public function __construct() {
                    $this->payment = new Paypal(); // tightly coupled
                }
            }
            ‚úÖ Good:
            class OrderService {
                public function __construct(PaymentMethod $payment) {
                    $this->payment = $payment;
                }
            }

** TRAIT
    traits allow to use resuable code in laguage like PHP where multiple inheritance is not supported
    e.g. // ‚ùå ERROR: Cannot extend multiple classes
    class C extends A, B { ... }
    class C {
        use Logger, Notifier;
        ...
    }

** Dependency Injection
    A design pattern where one object gives another object the things it needs (its dependencies) ‚Äî instead of making the object create them itself.
    e.g.
        class UserController {
            private $service;

            // ‚ùå Without Dependency Injection (Tightly Coupled)
            public function __construct() {
                $this->service = new UserService();
            }

            // ‚úÖ With Dependency Injection (Loosely Coupled)
            public function __construct(UserService $service) {
                $this->service = $service;
            }

            public function show() {
                return $this->service->getUser();
            }
        }


** Factory || Strategy || Singleton pattern
    FACTORY PATTERN
        creates objects without exposing the exact class name
        EXPLAINATION
            we need an object. But we dont need to manually write new someClass() everytime.
            instead we call a FACTORY METHOD and it return the correct object.
            tell the factory what you want, and it decides which class to create and returns it.

    STRATEGY PATTERN
        choose behavior at runtime by switching between different algorithms (strategies).
        Strategy is when you switch between different behaviors (algorithms) at runtime, like picking a payment method.
    SINGLETON PATTERN
        only one instance of a class exists in the application, and provides a global point of access to it.
        The singleton pattern ensures that only one instance of something (like a database connection) exists.


** Interface || Abstract Class
    ‚úÖ Interfaces say: ‚ÄúYou must do these things.‚Äù
    ‚úÖ Abstract classes say: ‚ÄúHere's a partial implementation ‚Äî override or extend me.‚Äù

    Interface                                           Abstract Class
    Define a contract (what must be done)               Define a base blueprint (what can be done)
    No properties                                       can have properties
    Only method signatures                              Can have both abstract & normal methods
    When you want to guarantee behavior             	When you want to reuse common logic

Static Binding + Late Static Binding
    binding means: Which method or property should PHP call at runtime?
        üß∑ Static Binding (self::)
        ‚è≥ Late Static Binding (static::)

    class ParentClass {
        public static function who() {
            echo "ParentClass\n";
        }

        public static function test() {
            self::who(); // STATIC BINDING
            OR
            static::who(); // LATE STATIC BINDING
        }
    }

    class ChildClass extends ParentClass {
        public static function who() {
            echo "ChildClass\n";
        }
    }

    ChildClass::test(); // Output: ParentClass ‚úÖ
    OR
    ChildClass::test(); // Output: ChildClass ‚úÖ


    | Feature            | `self::` (Static Binding) | `static::` (Late Static Binding) |
    | ------------------ | ------------------------- | -------------------------------- |
    | Resolves at        | Compile-time              | Run-time                         |
    | Uses method from   | Class where it's written  | Class that called the method     |
    | Inheritance aware? | ‚ùå No                      | ‚úÖ Yes                         |
    | Keyword used       | `self::`                  | `static::`                       |


How would you organize a large PHP codebase for maintainability
    1. Follow a Framework or Architectural Pattern
        Follow Laravel's structure or custom like
            app/
            ‚îú‚îÄ‚îÄ Models/
            ‚îú‚îÄ‚îÄ Http/
            ‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
            ‚îÇ   ‚îî‚îÄ‚îÄ Middleware/
            ‚îú‚îÄ‚îÄ Services/
            ‚îú‚îÄ‚îÄ Repositories/
            ‚îú‚îÄ‚îÄ Events/
            ‚îú‚îÄ‚îÄ Jobs/
            resources/
            routes/
            config/
            tests/

            /src
                /Controllers
                /Models
                /Views
                /Services
                /Utils

    2. Separate Concerns (SRP - Single Responsibility Principle)
        Each file/class/function should do only one job.
            Controllers: Handle HTTP/request logic
            Models: Represent and manage data
            Services: Contain business logic
            Repositories: Handle database access
            Helpers/Utils: Reusable tools

    3. Use Namespaces and PSR-4 Autoloading
        Use namespaces to organize classes logically and avoid conflicts.
        Then autoload using composer.json: (RUN: composer dump-autoload)

    4. Use Dependency Injection (DI)
        Avoid using new everywhere. Let dependencies be passed into constructors or via service containers (Laravel does this by default).

    5. Group Business Logic into Services
        Keep your controller lean. Push real logic into Service classes.

    6. Use Configuration Files
        Store them in .env and access via getenv() or config() in Laravel.
        Use a config/ folder for organized environment settings.

    7. Logging, Error Handling & Testing
        use try-catch
        Store tests in /tests and group by feature

    8. Consistent Coding Standards
        Use tools like PHP-CS-Fixer, PHP_CodeSniffer
        Name methods/variables meaningfully

    9. Use Composer for Dependencies
        Let composer.json manage everything

    10. Document Everything
        Use PHPDoc (/** */) for methods/classes
        Add README files and setup instructions












===========================================================================================
===============*************** üß™ Testing & Best Practices ***************=================
===========================================================================================

How do you write unit tests in PHP? What tools do you use (e.g., PHPUnit)?
    A unit test is a small test that checks if one unit (usually a function or method) of your code behaves as expected.
    üß™ PHPUnit - the standard and most widely used testing framework in PHP.
    HOW TO USE ?
        Install via Composer: composer require --dev phpunit/phpunit        OR        composer global require phpunit/phpunit (Globally)


Explain test doubles: stubs, mocks, fakes.
    TEST DOUBLE
        A test double is a generic term for any object that replaces a real object in a test.
    Types of Test Doubles
        ‚úÖ Stub	        Returns fixed data	            A vending machine that always gives Coke
        ‚úÖ Mock	        Verifies behavior/calls	        A spy that watches who called what
        ‚úÖ Fake	        Real logic but simplified	    A toy database in memory


How do you ensure your code is SOLID and testable?
    S	Single Responsibility	    Each class should do only one thing
    O	Open/Closed	                Open for extension, closed for modification
    L	Liskov Substitution	        Subtypes should be substitutable for base types
    I	Interface Segregation	    Don't force a class to implement unused methods
    D	Dependency Inversion	    Depend on abstractions, not concrete classes

What is code coverage and why does 100% coverage not always mean good tests?
    Code coverage means how much of your code is executed when your tests run.
    EXAMPLE
        function greet($name) {
            if ($name) {
                return "Hello, $name";
            }
            return "Hello, Guest";
        }
        $this->assertEquals("Hello, John", greet("John"));
        Then the line return "Hello, Guest"; is never tested, so coverage is less than 100%.

    ‚ùå Why 100% Coverage ‚â† Good Tests
        Getting 100% code coverage just means every line ran ‚Äî it doesn't guarantee the tests were meaningful.

















==========================================================================
==============*************** üõ°Ô∏è Security ***************=================
==========================================================================

** What are SQL Injections, how do you prevent them and what are the best practices?
    a security vulnerability where a malicious user can inject arbitary SQL code into query - potentially giving them access to, or control over, your database.
    Example of a Vulnerable PHP Code:
        <?php
            $username = $_GET['username'];
            $password = $_GET['password'];

            $sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
            $result = mysqli_query($conn, $sql);
        ?>

        NOW, If someone enters this in the URL:
        ?username=admin' --&password=anything

        It becomes:
        SELECT * FROM users WHERE username = 'admin' --' AND password = 'anything'
        The -- starts a comment, so the password part is ignored
        The attacker can log in as admin without a password

    Prevention
        1. Use Prepared Statements (Parameterized Queries)
            mysqli >
                $stmt = $conn->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
                $stmt->bind_param("ss", $username, $password);
                $stmt->execute();
            pdo >
                $stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username AND password = :password");
                $stmt->execute(['username' => $username, 'password' => $password]);
        2. Validate and Sanitize User Input
            $username = filter_input(INPUT_POST, 'username', FILTER_SANITIZE_STRING);

prevent XSS and CSRF attacks in PHP?
    XSS (Cross-Site Scripting)
        Attackers inject malicious JavaScript into pages ‚Äî often via forms or URLs ‚Äî which then runs in the browser of your users.
        User submits <script>alert('Hacked!')</script> and it shows up in a comment box.
    Prevent XSS
        Always escape user data before displaying it in HTML:
        echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');

        Blade automatically escapes output
        {{ $userInput }}            {{-- Safe --}}
        {!! $userInput !!}          {{-- NOT Safe (raw HTML) --}}

    CSRF (Cross-Site Request Forgery)
        A user is tricked into submitting a request (like form submit or money transfer) without their knowledge, using their logged-in session.
        While you're logged into your bank, a malicious site submits a form that transfers money.
    Prevent CSRF
        Use CSRF Tokens - Every form should include a unique hidden token & server checks if the token is valid
        In Raw PHP: Generate a token, store in session, and validate on submit:
            // On form load
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
            <input type="hidden" name="csrf_token" value="<?= $_SESSION['csrf_token'] ?>">

            // On form submit
            if ($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
                die('CSRF validation failed!');
            }


What is session fixation? How does PHP handle session security?
    Session fixation is a type of attack where:
        An attacker sets a known session ID (like ABC123) for a user.
        The user logs in.
        The attacker uses that same session ID to access the logged-in user's account.
    How can this happen?
        If your app lets users keep using the same session ID before and after login, the attacker can:
            Send a victim a link like: https://example.com/login?PHPSESSID=ABC123
            When the victim logs in, they keep using ABC123
            The attacker reuses ABC123 to hijack the session
    Prevent
        PHP has built-in tools to avoid this, especially:
        session_regenerate_id(true)         // This function creates a new session ID and deletes the old one.
        EXAMPLE
            session_start();           // Start session
            // ... Check login credentials ...
            session_regenerate_id(true);  // Prevent session fixation

    How PHP handles session security (Best Practices)
        | `session_regenerate_id()` after login   | Prevents session fixation attacks                        |
        | Use `httponly` cookie flag              | Prevents JavaScript from accessing `document.cookie`     |
        | Use `secure` cookie flag                | Ensures session cookies are sent **only over HTTPS**     |
        | Use `SameSite=Strict`                   | Prevents session cookies from being sent in CSRF attacks |
        | Store minimal sensitive info in session | Don't store passwords or tokens in session data          |
        | Set session timeout                     | Log out idle users after X minutes                       |


How do you store and verify passwords securely in PHP? (e.g., password_hash)
    password_hash() && password_verify()
    EXAMPLE
        // ‚úÖ When registering or saving password
        $hashedPassword = password_hash($password, PASSWORD_DEFAULT);
        // ‚úÖ When logging in
        if (password_verify($inputPassword, $hashedPassword)) {
            // Password is correct
        } else {
            // Invalid password
        }
    üîí Why it's secure:
        password_hash() uses strong algorithms like bcrypt or Argon2
        Automatically handles salting
        No need to manage salts or cost manually


validate and sanitize user input in PHP
    To prevent XSS, SQL injection, and other attacks ‚Äî never trust user input.
    ‚úÖ Sanitize = Clean unwanted/ unsafe characters
    ‚úÖ Validate = Check if it meets expected format
        // EMAIL
        $email = filter_input(INPUT_POST, 'email', FILTER_SANITIZE_EMAIL);
        if (!filter_var($email, FILTER_VALIDATE_EMAIL))
            echo "Invalid email!";

        // AGE
        $age = filter_input(INPUT_POST, 'age', FILTER_VALIDATE_INT);
        if ($age === false)
            echo "Age must be a number!";

        // Manual sanitizing for strings (e.g., XSS protection)
        $safeString = htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');


prevent file upload vulnerabilities in PHP
    // File upload
    | Limit file types           | Check MIME types and file extensions |
    | Check file size            | `$_FILES['file']['size']`            |
    | Store outside web root     | So files can't be accessed via URL   |
    | Rename uploaded files      | Use `uniqid()` or random names       |
    | Validate MIME type         | Use `finfo_file()`                   |
    | Block `.php`, `.exe`, etc. | Reject these explicitly              |











==========================================================================
========************ üìà PERFORMANCE & OPTIMIZATION ************===========
==========================================================================

How do you optimize/ performance improve large-scale PHP applications?
    | **Code-level**         | Use efficient algorithms, avoid deep loops, clean up logic                             |
    | **Database**           | Use indexes, avoid N+1 queries, optimize joins                                         |
    | **Caching**            | Use Laravel/Redis/OPcache to avoid repeating expensive operations                      |
    | **Autoloading**        | Use PSR-4 autoloading, optimize Composer autoloader                                    |
    | **Sessions**           | Store sessions in Redis/memcached for faster access                                    |
    | **Asset Optimization** | Minify JS/CSS, use CDN, lazy load assets                                               |
    | **Profiling**          | Use tools like **Xdebug**, **Blackfire**, or **Laravel Telescope** to trace slow spots |


What are common bottlenecks in PHP applications and how do you identify them?
    üß± Common Bottlenecks:
        Slow database queries
        Too many queries (N+1)
        Memory leaks or large memory use
        Slow external APIs
        File I/O (reading/writing large files)
        Synchronous processes (e.g. sending emails without queues)
    üîç How to Identify:
        | **Laravel Telescope**             | View DB queries, request lifecycle, queue jobs           |
        | **Xdebug** / **Blackfire**        | Profile PHP function calls and execution time            |
        | **MySQL EXPLAIN**                 | Analyze SQL query performance                            |
        | **Logging**                       | Add `Log::info()` at critical paths to measure execution |
        | **Chrome DevTools + Network tab** | Frontend bottlenecks, slow API endpoints                 |


How would you scale a PHP application (horizontally vs vertically)?
    | **Vertical Scaling**   | Increase power (CPU/RAM) of a single server | Upgrade your VPS or EC2 instance                    |
    | **Horizontal Scaling** | Add more servers and balance the load       | Use multiple PHP app servers behind a Load Balancer |


What are PHP OPcache and realpath_cache? How does OPcache improve PHP performance?
    üî• What is OPcache?
        OPcache stores the compiled bytecode of PHP scripts in memory
        So PHP doesn't re-parse and recompile .php files every request
        ‚úÖ Enabled by default in PHP 7+
        ‚úÖ Drastically improves performance (especially for large apps)
    üß† What is realpath_cache?
        It caches the real file system paths of files to avoid repeated stat() system calls
        Useful for frameworks (like Laravel) with tons of file includes

    üß© Normally, without OPcache:
        Every time a PHP file is requested:
            PHP reads the file
            Parses it (converts code to internal instructions)
            Compiles it into bytecode
            Executes it
    üöÄ With OPcache enabled:
        The first time a script is executed:
            PHP parses and compiles the file
            But now, OPcache stores the compiled bytecode in memory
        On the next request:
            PHP skips reading & compiling
            It directly runs the cached bytecode
        ‚úÖ This is faster because:
            No disk I/O
            No parsing
            No compiling









=======================================================================
========************ ‚öôÔ∏è Composer & Autoloading ************===========
=======================================================================

What is Composer? How does PSR-4 autoloading work?
COMPOSER
    Composer is a dependency manager for PHP.
        üì¶ Install and manage libraries (like Laravel, Guzzle, PHPUnit)
        üîÑ Automatically load them using autoloading
        üìú Keep track of packages and versions in a composer.json file

What's the difference between require, require-dev, and autoload in composer.json?
    1. ‚úÖ require
        Used to declare packages your app needs to run in production
        These are essential dependencies
        "require": {
            "laravel/framework": "^10.0",
            "guzzlehttp/guzzle": "^7.0"
        }
    2. üß™ require-dev
        Used for development-only packages
        Not needed in production
        "require-dev": {
            "phpunit/phpunit": "^10.0",
            "friendsofphp/php-cs-fixer": "^3.0"
        }
    3. ‚öôÔ∏è autoload
        Defines how Composer autoloads your own PHP classes
        You don't need to require files manually ‚Äî it's automatic
        "autoload": {
            "psr-4": {
                "App\\": "app/"
            }
        }


How do you create a reusable Composer package?
    1. Create a folder for your package
        mkdir my-awesome-package
        cd my-awesome-package
    2. Initialize with Composer
        composer init
    3. Use PSR-4 autoloading
        "autoload": {
            "psr-4": {
                "Suvajit\\MyPackage\\": "src/"
            }
        }
    4. Add your classes in src/ - example - src/Helper.php
        namespace Suvajit\MyPackage;
        class Helper {
            public static function hello() {
                return "Hello from MyPackage!";
            }
        }
    5. Test locally
        In a separate Laravel or PHP project: composer require path/to/my-awesome-package
    6. Publish your package (optional)
        Push to GitHub
        Add type: "library" in composer.json
        Submit to Packagist.org to make it publicly installable
















==============================================================================
========************ üîß Database & Query Optimization ************===========
==============================================================================

How do you prevent N+1 query problems in PHP?
    The N+1 problem happens when you run 1 query to get N items, and then N more queries to get related data.
    This results in a lot of queries, slowing things down.
    EXAMPLE of N + 1 problem
        $users = $db->query("SELECT * FROM users"); // 1 query
        foreach ($users as $user) {
            $posts = $db->query("SELECT * FROM posts WHERE user_id = {$user['id']}"); // N queries
        }
    SOLUTION Use a JOIN/ IN query
        $usersWithPosts = $db->query("
            SELECT users.*, posts.*
            FROM users
            LEFT JOIN posts ON posts.user_id = users.id
        ");
        OR in LARAVEL
        User::with('posts')->get(); // Prevents N+1


Explain the difference between prepared statements and stored procedures.
    | Feature    | **Prepared Statements**                                      | **Stored Procedures**                   |
    | ---------- | ------------------------------------------------------------ | --------------------------------------- |
    | What it is | A **safe way** to run SQL with placeholders                  | A **saved SQL script** stored in the DB |
    | Written in | PHP (via PDO or mysqli)                                      | Inside the **MySQL database**           |
    | Purpose    | Prevent SQL injection, reuse SQL                             | Encapsulate logic, reduce network trips |
    | Example    | `$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");` | `CALL getUserById(5);`                  |


PDO + Why use PDO over mysqli?
    PHP Data Objects - A database access layer that works with many databases: MySQL, PostgreSQL, SQLite, etc.

    Use PDO when:
        You want clean, reusable, secure code.
        You might switch databases in the future.

    | Feature          | **PDO**                     | **mysqli**            |
    | ---------------- | --------------------------- | --------------------- |
    | Database support | Works with many DBs         | Only works with MySQL |
    | Prepared Stmt    | Supports named + positional | Positional only       |
    | Code portability | High                        | Low                   |
    | OOP support      | Fully object-oriented       | Object + procedural   |


How do you handle transactions in PHP with PDO?
    A transaction lets you run multiple queries safely as a group ‚Äî either all succeed or all fail.
    EXAMPLE
        $pdo->beginTransaction(); // Start
        try {
            $pdo->exec("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
            $pdo->exec("UPDATE accounts SET balance = balance + 100 WHERE id = 2");

            $pdo->commit(); // All OK ‚úÖ
        } catch (Exception $e) {
            $pdo->rollBack(); // Revert if error ‚ùå
        }


How would you design a schema for millions of rows? Any indexing tips?
    Design tips:
        Use appropriate data types (INT instead of BIGINT if possible). - Smaller data types = Less memory usage
            Suppose your table has 100 million rows. Using BIGINT instead of INT means:
            4 extra bytes x 100 million = ~400 MB more used.
        Archive old data if possible (partitioning, separate tables).
        Normalize to reduce duplication, but denormalize carefully if reads are slow.
    Indexing tips:
        Add indexes to columns used in: WHERE/ JOIN/ ORDER BY
        Use composite indexes (INDEX (user_id, created_at)) if you filter/sort by both.
        Use EXPLAIN to check if your index is being used.
    Caution: Don't over-index ‚Äî every index slows down inserts/updates.


How would you optimize a slow SQL query?
    1. Use EXPLAIN: EXPLAIN SELECT * FROM orders WHERE user_id = 5;
        ‚Üí Shows if indexes are used, rows scanned, etc.
    2. Add proper indexes:
        CREATE INDEX idx_orders_user_id ON orders(user_id);
    3. Avoid SELECT * : Only select needed columns. (Select * fetches unnecessary data)
        When to use 'SELECT *'
            When you're doing COUNT(*), which just counts rows (doesn't fetch columns).
            SELECT COUNT(*) FROM users;
    4. Limit large data sets: LIMIT 50 OFFSET 0
    5. Optimize JOINs:
        Use indexes on foreign keys.
        Avoid joining huge tables unnecessarily.
    6. Avoid subqueries in SELECT/WHERE if possible:
        Convert to JOIN or WITH clause (CTEs).
    7. Check for slow functions in WHERE clauses:
        WHERE DATE(created_at) = '2024-01-01' -- ‚ùå slow
        WHERE created_at BETWEEN '2024-01-01 00:00:00' AND '2024-01-01 23:59:59' -- ‚úÖ













============================================================================================
========************ üß† Scenario-Based / System Design ************===========
============================================================================================

Design a REST API in PHP ‚Äî what tools, patterns, and structure would you use?
    üß∞ Tools:
        PHP Framework: Laravel, Slim, or Lumen (for lightweight APIs)
        Database: MySQL, PostgreSQL
        Web server: Apache or Nginx
        HTTP Client: Postman (for testing)
    üß† Patterns:
        MVC (Model-View-Controller) to separate logic
        Routing to handle endpoints
        Middleware for things like auth, CORS
        Validation layer to sanitize input
    üìÅ Folder Structure:
        /api
        ‚îî‚îÄ‚îÄ controllers/
        ‚îî‚îÄ‚îÄ models/
        ‚îî‚îÄ‚îÄ routes/
        ‚îî‚îÄ‚îÄ middleware/
        ‚îî‚îÄ‚îÄ helpers/

How would you build a modular plugin-based architecture in PHP?
    Allow developers to add features (plugins) without changing the core system.
    Use:
        Autoloading (PSR-4)

How do you build multi-tenant apps in Laravel or plain PHP?
    One app, multiple clients (tenants) with separate data.
        Each tenant has their own DB
        One DB, separate schemas (PostgreSQL only)
        One DB, one table, tenant_id in every row


How do you ensure code reusability across multiple PHP projects?
    Packages: Use Composer to create and distribute shared packages.
    Traits: Share common methods (e.g., HasSlug, LogsActivity)
    Interfaces/Contracts: Define expected behavior
    Environment-based Configs: .env files per project


Write a function to detect palindrome in PHP.
    Converts the string to lowercase
    Uses two pointers: one from the start, one from the end
    Skips any non-alphanumeric characters using ctype_alnum()
    Compares characters until pointers meet

    EXAMPLE
        var_dump(isPalindrome("madam"));           // true
        var_dump(isPalindrome("racecar"));         // true
        var_dump(isPalindrome("Hello"));           // false
        var_dump(isPalindrome("A man, a plan, a canal, Panama")); // true

    CODE
        function isPalindrome($string) {
            $string = strtolower($string); // make it case-insensitive
            $left = 0;
            $right = strlen($string) - 1;
            while ($left < $right) {
                // Skip non-alphanumeric characters
                if (!ctype_alnum($string[$left])) {
                    $left++;
                    continue;
                }
                if (!ctype_alnum($string[$right])) {
                    $right--;
                    continue;
                }
                if ($string[$left] !== $string[$right]) {
                    return false;
                }
                $left++;
                $right--;
            }
            return true;
        }


Write a class in PHP implementing Singleton design pattern.
    Singleton ensures a class has only one instance.
        class Singleton {
            private static $instance = null;

            private function __construct() { }

            public static function getInstance() {
                if (!self::$instance) {
                    self::$instance = new Singleton();
                }
                return self::$instance;
            }
        }

        // Usage
        $obj1 = Singleton::getInstance();
        $obj2 = Singleton::getInstance();
        var_dump($obj1 === $obj2); // true


How would you structure a large-scale PHP application?
    Structure
        /app
            ‚îî‚îÄ‚îÄ Http/
            ‚îî‚îÄ‚îÄ Models/
            ‚îî‚îÄ‚îÄ Services/
            ‚îî‚îÄ‚îÄ Repositories/
            ‚îî‚îÄ‚îÄ Jobs/
            ‚îî‚îÄ‚îÄ Events/
            ‚îî‚îÄ‚îÄ Helpers/
        /routes
        /config
        /resources
        /tests
    üß† Patterns:
        MVC for clean separation
        Repository Pattern for data access
        Service Layer for business logic
        Event-Driven for handling actions like "user registered"
    üõ† Tools:
        Laravel, Symfony
        Docker for environment
        Redis for caching
        RabbitMQ/Queue for background jobs
        Testing: PHPUnit













============================================================================================
========************ ‚öôÔ∏è DevOps & Deployment ************===========
============================================================================================

How do you deploy PHP applications ‚Äî CI/CD, Docker, GitHub Actions, etc.?
    üß∞ Common Tools:
        CI/CD: Automates testing + deployment (CI = test, CD = deliver/deploy)
        GitHub Actions: Runs automation when you push to GitHub
        Docker: Packages your app with its environment so it runs the same everywhere
        FTP/SSH: Manual way (but avoid for big projects)
    üß± Docker-based Deployment (simple idea):
        Define your app + webserver in a Dockerfile or docker-compose.yml
        Run the same container locally and on production
        Push to a server or use services like Render, DigitalOcean App Platform, etc.
    



How do you manage PHP versioning and dependencies in production?
    PHP Version:
        Use phpenv, Docker, or your hosting provider's version manager
        Set version in .tool-versions or Dockerfile
    Dependencies:
        Managed using Composer (composer.json)
        Production install:
            composer install --no-dev --optimize-autoloader


How do you use .env configuration securely in production environments?
    .env stores sensitive or environment-specific values:
    Store different .env files for: .env.local     &     .env.staging     &    .env.production
    Never commit it to GitHub. Add .env to .gitignore
    Use server secrets if possible:
        env:
            DB_PASSWORD: ${{ secrets.DB_PASSWORD }}









============================================================================================
========================************ üóÇ PSR Standards ************===========================
============================================================================================

PSR
    PHP Standards Recommendations, a coding style guide

What are PSR-1, PSR-4, PSR-7, and PSR-12?
    PSR-1: Basic Coding Standard
        Class names must use StudlyCaps
        Method names must be camelCase
        PHP files must use <?php only
    PSR-4: Autoloading Standard
    PSR-7: HTTP Message Interfaces
    PSR-12: Extended Coding Style

What's the benefit of following PSR standards in large teams/projects?
    | ‚úÖ **Consistency**        | Everyone writes code in the same style              |
    | ‚úÖ **Readability**        | Easier to read, debug, and maintain                 |
    | ‚úÖ **Team Collaboration** | Anyone can jump into any part of the project        |
    | ‚úÖ **Tool Compatibility** | Works better with IDEs, linters, and autoformatters |
    | ‚úÖ **Reusable Code**      | Easier to share libraries and packages              |
    | ‚úÖ **Framework Interop**  | Your app can plug into modern frameworks smoothly   |

How do you use PSR-7 (HTTP message interfaces) in a custom microservice?
    1. Install a PSR-7 implementation (like Nyholm or Laminas)
        composer require nyholm/psr7
    2. Example Microservice Handler:
        use Psr\Http\Message\ServerRequestInterface;
        use Psr\Http\Message\ResponseInterface;
        use Nyholm\Psr7\Response;

        function handleRequest(ServerRequestInterface $request): ResponseInterface
        {
            $params = $request->getQueryParams();
            $name = $params['name'] ?? 'Guest';

            $response = new Response();
            $response->getBody()->write("Hello, $name!");

            return $response->withHeader('Content-Type', 'text/plain');
        }
    3. Use it in a micro-framework like Slim
        $app->get('/hello', function (ServerRequestInterface $request, ResponseInterface $response) {
            return handleRequest($request);
        });








=============================================================================================
================************ ü§î Behavioral / Experience-Based ************===================
=============================================================================================

Tell us about a time you optimized a slow PHP application.
    üß† Situation:
        We had a Laravel-based e-commerce dashboard that was painfully slow when loading reports ‚Äî especially with over 500k orders.
    üîç Problem:
        The backend was fetching related data using Eloquent relationships inside loops, causing an N+1 query problem, plus some filters weren't indexed in the database.
    üõ† Solution:
        Replaced lazy loading with Eloquent eager loading using with()
        Refactored report logic to use DB::raw() with optimized joins
        Added indexes on order_date and customer_id
        Cached frequently accessed data using Redis
    üìà Result:
        API response time improved from ~7 seconds to under 800ms
        Server load dropped by ~30%
        Happier stakeholders and a more scalable reporting tool

What was your biggest architecture challenge in PHP, and how did you solve it?
    üß† Challenge:
        Building a multi-tenant SaaS platform using Laravel, with each tenant needing isolated data, separate branding, and performance safeguards.
    üòì Problems:
        Handling data isolation without duplicating models/controllers
        Managing domain-based routing and tenant-specific environment configs
        Making migrations per-tenant and dynamically switching DB connections
    üõ† Solution:
        Used row-based multi-tenancy with a global tenant_id filter (via a middleware + scoped models)
        Used spatie/laravel-multitenancy to manage tenant context and DB switching
        Implemented a central event system + job queues for tenant events
    üí° Key Outcome:
        Allowed onboarding hundreds of clients with no code duplication
        Was able to add tenant-specific features using feature flags and plugin-like service providers

How do you mentor junior developers in PHP best practices?
    | üß© Pair Programming           | Code side-by-side so they learn by doing ‚Äî not just watching                       |
    | ‚úÖ Code Reviews               | I give actionable feedback, focusing on **readability**, **naming**, and **SOLID** |
    | üìö Learning Path              | I suggest a roadmap: start from syntax ‚Üí OOP ‚Üí frameworks ‚Üí design patterns        |
    | üß™ Test-Driven Mindset        | Encourage writing unit tests and teach them TDD for small tasks                    |
    | üß± Explain Design Patterns    | Teach patterns like Factory, Singleton, Repository with **real examples**          |
    | üß† Ask "why", not just "what" | I help them think about **why** a pattern or rule is good for maintainability      |

How do you stay up to date with PHP trends and improvements?
    | üìö Official PHP News    | [https://www.php.net/releases/](https://www.php.net/releases/) |
    | üêò Laravel News         | Latest Laravel + PHP ecosystem trends                          |
    | üõ† GitHub               | Watch popular repos like Symfony, Laravel, Pest, PHPStan       |
    | üé• YouTube & Conf Talks | Laracon, PHP\[TEK], Nuno Maduro, Brent Roose                   |
    | üßµ Twitter/X & Dev.to   | Follow folks like @philsturgeon, @brendt\_gd, @nunomaduro      |
    | üë®‚Äçüíª Open Source       | Contribute or read PRs in frameworks/tools                     |
















