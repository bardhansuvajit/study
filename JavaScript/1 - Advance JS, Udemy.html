HISTORY
original named Mocha > LiveScript > JavaScript
created by Brendan Eich in 1995


WHY ?
create interactive effect, alter page without reload, repond to user event/ action, fetch & send info to server


JAVASCRIPT ENGINE

> JS is single threaded language (only one statement is executed at a time) that uses callback key. 
> JS is also called a interpreted language
> Brendon Eich first created JS & JS engine


INTERPRETER
reads & translates code line by line.
COMPILER
reads & understands entire code, optimises if required & then translates into machine language.

** Interpreter is initially faster than Compiler, but doesn't do optimization. Like, for a chunk of code/ when loops exist in code, it makes the process slower. Compiler does a better job here, as it understands the entire code first and optimizes it. So, to make the engines faster, JIT COMPILER (Just in Time) is introduced, using both Interpreter & Compiler

JS IS NOT ENTIRELY AN INTERPRETED LANGUAGE
Normally, High-level language, like JS, converted into bytecode, then to machine code. Computers doesn't understand bytecode. Then a JVM (Java Virtual Machine) or JS engine is needed to execute bytecode to executable code. So, in JS, Interpreter & Compiler both are used and it's not an interpreted language. The first JavaScript engines were using Interpreters, but all modern engines use JIT (just-in-time) compilation for improved performance.


ECMAScript engine/ JS engine is a program that executes source code to computer language. 
Example V8 (written in C++, used in chrome, node js), WarpMonkey (used in firefox), Chakra (legacy, used in IE), v8 is also used by Edge, Brave, Opera, Nitro (Safari)

**ECMASCRIPT
ECMAScript is a STANDARD for scripting language, which defines how Javascript code standard should be.


HOW JS ENGINE WORKS
when a code is passed to the engine, it's parsed to a data structure AST (Abstruct Syntax Tree). AST is used to create machine codes


** HOW V8 ENGINE WORKS
Code is parsed (code is read & understood)
→ converted into an AST (Abstract Syntax Tree)
→ passed to the interpreter (called Ignition in V8)
→ turned into bytecode
→ code runs immediately using the bytecode

→ Meanwhile, a Profiler (also called the "monitor") watches the code while it runs, looking for "hot" code (frequently used)
→ When hot code is detected, it is sent to the JIT compiler (called TurboFan in V8)
→ TurboFan compiles that bytecode into optimized machine code
→ The optimized machine code replaces the old version for faster execution



BABEL
a Javascript compiler that takes your modern JS code and returns browser compatible JS (older JS code).
TYPESCRIPT
a superset of Javascript that compiles down to Javascript.
BABEL & TYPESCRIPT does same thing as compiler. Takes one language & converts into a different one


WRITE OPTIMIZED JAVASCRIPT CODE/ BEST PRACTICES
We need to write code in a way that helps the Compiler (JIT) make optimization. We don't need to work against it & make it slow. Careful with the followings
eval(), arguments, for in loop, with, delete


** INLINE CACHING
in case of repetating calls to the same method, V8 caches the information from previous lookups. That's how it optimizes
** HIDDEN CLASSES
used to optimize property access time. V8 attaches a hidden class to every object. 


WEB ASSEMBLY/ Wasm
Provides a way to run codes written in multiple languages on the web at near-native speed Standard Bynary Executable Format. 


** CALL STACK & MEMORY HEAP
The main work of JS is to read code & translate it to machine language. So,
1. we need a place to store & write information in memory like, variables, objects, data (Memory Heap - allocate, use & release memory) and
2. a place to actually run & keep track of what's happening line by line (Call Stack).
EXAMPLE
const number = 610 // allocate memory for 'number' variable and point in memory heap to value 610
const person = { // allocate memory for an object and it's values
    firstName: 'David',
    lastName: 'Lang'
}

How does Call Stack work !
For a simple sum() function, when it's called, it's allocated to memory. First, the sum() function is added to the top of Call Stack. After finish running it's removed from the stack. Operates as First in Last out.
To check, how ti functions, goto Chrome developers option -> Sources -> Snippets -> New Snippet -> write function codes -> add 'debugger;' to see how call stack is functioning -> an 'anonymous' function is added to stack (called Global Execution Context)

simple variables are stored in Stack & complex data structures (objects, arrays) are stored in memory heap.


** STACK OVERFLOW
when functions are nested inside each other & called over and over again, the stack keeps adding functions, without popping them off and gets larger. That's Stack Overflow. (Error appears, max call stack size exceeded)


** GARBAGE COLLECTION
JS is a garbage-collected language. Meaning, if JS allocates memory, automatically when we finish calling the object and if we don't need the object anymore/ no reference for it in our program, JS will clean it, keeps the memory free. So that we don't use up all the memory. 

Garbage Collection in JS uses Mark and Sweep algorithm, when reference to a variable is removed, it's deleted


** MEMORY LEAKS
create an infinite loop, that would fill up our memory & browser will crash. as nothing is popped off the stack. 
Common Memory Leaks
1. Using too many GLOBAL VARIABLES, all our memory will get used up
2. Keep adding EVENT LISTENERS, when using too many and not removed
3. OBJECTS IN SETINTERVAL, they will never be garbage-collected, unless removed itself
Remember, memory is limited. JS runs and stores memory in CALL STACK & MEMORY HEAP. Do not have STACK OVERFLOW & MEMORY LEAK 


** SINGLE THREADED PROGRAMMING LANGUAGE (SYNCHRONOUS)
Means one set of instruction is completed at a time. To check if a language is Single Threaded, if it has one Call Stack (and one Memory Heap). We push & pop functions/ statements one by one. 
So, JS is SYNCHRONOUS, only one thing at a time. (Like, using one hand at a time while eating. Use hand to pick up food, chew it, finish it, then repeat)

ISSUE WITH SINGLE THREADED/ SYNCHRONOUS CODE
a statement has to wait for the earlier statement to finish executed. If one statement is going to take a lot of time, things are going to be really slow for the program. JS RUNTIME helps us with that


DOM - Document Object Model
represents HTML document as tree. Each div/ h1/ p tags acts as node of the tree. JS is used to alter elements. eg. change color, size etc
BOM - Browser object model
JS is used to change brower feature outside HTML page. eg. window, navigator, location, screen, history



** JS RUNTIME/ WEB API
the Web browser works in the background, when the synchronous JS code is running. It does this by using WEB API (Web API comes with browser, and with low level languages like C++).

WEB API is used to send HTTP Request (fetch), listen to DOM event, delay executions (SetTimeout), used for Caching, Database Storage in browser (indexedDB) etc. (To check simply goto console and type 'window')

WEB APIs are ASYNCHRONOUS - means, we can instruct the APIs to do something in the background and return data once done. Meanwhile, we can continue working on JS Call Stack & execute functions

WEB API runs only when the stack is empty & the entire file is completed running

HOW IT WORKS
EXAMPLE 1
console.log(1) // sent to Call Stack
setTimeout(() => {console.log(2)}, 1000) // sent to Web API, after 1 second it pushes the callback/ console.log(2), which goes into CALLBACK LOOP. EVENT LOOP checks for if the CALL STACK is empty
console.log(3) // sent to Call Stack

OP -> 1 3 ... 2

WEB API, CALLBACK QUEUE, EVENT LOOP

EXAMPLE 2
function archiveNirvana() {
    console.log('Here we are')
}
function c() {
    setTimeout(archiveNirvana, 1000)
}
function b() {
    c();
}
function a() {
    b();
}
a()

OP -> ... 'Here we are'

CALL STACK, WEB APIs, CALLBACK QUEUE - Check the process here
http://latentflip.com/loupe/?code=ZnVuY3Rpb24gcHJpbnRIZWxsbygpIHsNCiAgICBjb25zb2xlLmxvZygnSGVsbG8gZnJvbSBiYXonKTsNCn0NCg0KZnVuY3Rpb24gYmF6KCkgew0KICAgIHNldFRpbWVvdXQocHJpbnRIZWxsbywgMzAwMCk7DQp9DQoNCmZ1bmN0aW9uIGJhcigpIHsNCiAgICBiYXooKTsNCn0NCg0KZnVuY3Rpb24gZm9vKCkgew0KICAgIGJhcigpOw0KfQ0KDQpmb28oKTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D


JAVASCRIPT ENGINE vs RUNTIME
JS ENGINE's only task is to read code, translate into machine code & run it
JS RUNTIME's a place/ environment where code executes. Like, DOM is a part of outside world. ECMAScript has no specifications on how JS should interact with the outside world. These rules comes from JS RUNTIME


NODE JS
is a JAVASCRIPT RUNTIME, not a language/ framework (made with C++). To run JS outside browser. Uses Google V8 engine to understands JS. Uses LIBUV library to use as Event Loop. 


EXECUTION CONTEXT
when JavaScript engine scans a script file, it makes an environment called Execution Context that handles the entire transformation and execution of code
2 types of Execution Context - Global & Function

Global() -> when a script first starts to run, JS engine automatically creates the Global Execution Context at the beginning of the Stack. At the beginning, a Global object (/ the window object in browser environment) & 'this' keyword is created at the stack


** LEXICAL ENVIRONMENT(/ SCOPE/ ANALYSIS/ CLOSURE) - Available data + variables where the function was defined
It is a Data Structure/ an ability that stores variables & functions, defined in current scope and all of it's outer scope. It is created when a function is called & destroyed when function returns.

It is used to resolve variable names. When the JavaScript interpreter encounters a variable name, it looks for the variable in Lexical Environment of Current Scope, if not found, looks for it in the Outer Scope and so on till it reaches the Global Scope. ** If still not found, interpreter throws a 'ReferenceError' exception.

FUNCTION LEXICAL ENVIRONMENT
when functions are called inside each others. One function is connected to another function and like that


** HOISTING
JS Interpreter's action of moving all variables and function declarations to the top of current scope. Functions are hoisted first, then variables. Functions are fully hoisted whereas, variables are partially. Variables are set as undefined first.

EXAMPLE
console.log('line 1')
var teddy = 'bear'
console.log(teddy)

OP >>
line 1
bear
undefined // in a typical browser, console.log doesn't return anything, so, undefined

AGAIN
console.log('line 1')
console.log(teddy)
var teddy = 'bear'

OP >>
line 1
undefined // 'teddy' is not defined earlier. so, JavaScript works as, 'teddy' is a variable. var teddy = undefined
undefined // console log doesn't return anything, so, undefined

** same thing doesn't apply for functions. You can declare it later but still call earlier and it would work just fine.
** only works with var/ function. not let/ const. it throws a 'ReferenceError' exception.

// Function Declaration - always start with function keyword | gets hoisted | cannot be called immediately after creating it
function sing() {
    console.log('ohh la la')
}

// Function Expression - does not start with function keyword | does not get hoisted | can be called immediately after creating it (IIFE)
var sing2 = function() {
    console.log('uhh la la');
}

* sing2 will be hoisted as variable if called earlier (console.log(sing2))
but would throw error as function (console.log(sing2()))

EXAMPLE
var favouriteFood = "grapes";
var foodThoughts = function () {
  console.log(`Original favourite food: ${favouriteFood}`);

  var favouriteFood = "Sushi";

  console.log(`New Favorite Food: ${favouriteFood}`);
};
foodThoughts();

OP >>
Original favourite food undefined (as local scope hoisting happens here, favouriteFood is called in next line)
New Favorite Food Sushi

* Hoisting is bad practice. Try using const/ let, instead of var


FUNCTION INVOCATION
calling/ invoking a function means same. like executing/ running.
'Calling' meansusing function name followed by parenthesis `()`. When called, we are asking the program to execute the code inside that function.
'Invoking' a function is same as calling. It means causing the function to execute and perform it's task. The term 'Invoke' is more formal. in Summary both are same

function marry(person1, person2) {
    console.log(arguments)              // 'arguments' object for function
    console.log(Array.from(arguments))  // convert into array
}
marry('Tim', 'Tina')        >>      OP       >>     
{ 0: 'Tim', 1: 'Tina' } //  object
[ 0: 'Tim', 1: 'Tina' ] //  array

myFunction() // calling a function, just an example
marry(11, 2) // invoking a function, just an example


Again,
Using REST PARAMETERS, allows JS to accept indefinite number of arguments as array. This is modern JS
// `...` is Spread Operator
function marry2(...args) {
    console.log(args)
}


VARIABLE ENVIRONMENT
variables inside each functions are kept in Variable Environment


SCOPE CHAIN
Global & Local Scope - Variables defined globally/ locally (inside functions), can be accessed accordingly

UNDEFIENED vs NOT DEFINED
Undefined means we have the variable, but it's not assigned anything right now
ReferenceError/ Not Defined means, does not exist or not defined in current scope

[[SCOPES]]
EXAMPLE
simply goto console >> type a function a() {} >> type window >> you can access [[Scopes]] for function a >> it says, { type: "global",... }


LEAKAGE OF GLOBAL VARIABLE
When no data type (var/ const/ let) is used while declaraing a variable, whether inside a function, it goes into global environment

STRICT
'use strict' -> add this at top of the script, the leakage won't happen. Also, used to avoid many common mistakes in Javascript


FUNCTION SCOPE vs BLOCK SCOPE
FS - when a variable is declared inside function, is only accessible within that function
BS - when a variable is declared inside if/ switch statement/ inside for/ while loops are inside Block Scope. Almost inside any `curly braces`
Most programming languages does not support Block Support, JS does.
EXAMPLE
if (5 > 4) {
    var secret = '12345';       // this is Block Scoping
}
console.log(secret)     >> OP >>        12345

Now, let/ const is introduced in ES6. They allow us to use Block Scoping properly. If secret is used like, let/ const secret = '12345'... it would not be accessed outside


VAR vs LET vs CONST
var - function-scoped variables, that can be hoisted
let - block scoped variables, that can be reassigned, cannot be hoisted
const - block scoped variables, that are constant & cannot be reassigned, cannot be hoisted


GLOBAL VARIABLES - avoid using them
1. To avoid complexity, not all variables can be called in Global Scope. Because our memory is limited and it would overflow or make things slower. 
2. In large applications, we might have multiple script tags and same name variables might cause problem

** IIFE (Immediately Invoked Function Expression)

(function() {
    ...codes/ define Global Variables
})();

// this is a function expression. Creating an anonymous function and immediately invoking/ calling it. SO using IIFE solves the global variable problem. All the Global Variables can be called inside IIFE

EXAMPLE
var Calculator = (function() {
    function add(x, y) {
        return x + y;
    }

    function subtract(x, y) {
        return x - y;
    }

    return {
        add: add,
        subtract: subtract
    };
})();

Calculator.add(5, 3)    >>  OP  >>  8

NOW, while using jQuery, they created an IIFE by using $ keyword. The $/ jquery is added to the window object. write window.$/ window.jQuery in console after including jquery to script
Basic jquery syntax is $().();

** The $ in jquery can also be changed
(function (OMG) { // changing the jQuery parameter
    // $('h1').hide();
    OMG('h1').hide();
})(jQuery); // passing jQuery parameter & JS looks for it in local scope rather than global


** this KEYWORD
this is a object that the function is a property of. Like, a simple function is a property of window object. Remember to use DRY (Dont Repeat Yourself) method, that's why 'this' is used. With 'this' keyword -
1. methods can access their object
2. execute same code for multiple objects

EXAMPLE
const obj = {
    name: 'Billy',
    job: function() {
        return this.name + ' can sing'
    },
    sing() {
        return 'lalala ' + this.name
    },
    singAgain() {
        return this.sing(). + '!'
    }
}
obj.job()           >> OP   >> Billy can sing
obj.singAgain()     >> OP   >> lalala Billy!

EXAMPLE - 
function person() {
    console.log('Person is ' + this.name)
}
const name = 'Sunny';
const obj1 = {
    name: 'Casey',
    person: person
}
const obj2 = {
    name: 'Jacob',
    person: person
}
person()        >> OP   >> Person is Sunny
obj1.person()   >> OP   >> Person is Casey
obj2.person()   >> OP   >> Person is Jacob


Note,
'this' keyword is not Lexically Scoped. Doesn't matter where it is written. Matters how the function was called. which is a problem. To solve it, ES6 introduced Arrow Function, which are Lexically bound. 
Before ES6 you could use bind() to solve this/ store 'this' in a variable and use it inside nested function


** CALL(), APPLY(), BIND()
These functions are used to manipulate 'this' keyword. call() & apply() are simply used to call a function. Like, someFunction() OR someFunction.call() OR someFunction.apply() does the same thing, for now.

EXAMPLE
const wizard = {
    name: 'Merlin',
    health: 50,
    heal() {
        return this.health = 100;
    }
}
const archer = {
    name: 'Robin',
    health: 30
}
wizard.heal()   >> OP >>    100

// Now, 'Robin' has less health. It would be good if he could borrow the healing factor from 'Merlin'. But we also want to use DRY method, also do not want to overflow the stack. So, 

wizard.heal.call(archer)

call() can also have arguments, like
heal(num1, num2) {
    return this.health += num1 + num2;
}
wizard.heal.call(archer, 50, 30)                            >> CALL()
OR
wizard.heal.apply(archer, [50, 30])                         >> APPLY()
OR
const healArcher = wizard.heal.bind(archer, 100, 30)        >> BIND()
healArcher()

Bind() allows us to store for later use. Call() and Apply() execute the current function immediately. Also we can do Function Currying (partially giving a function parameter) with bind()

CURRYING EXAMPLE
function multiply(a, b) {
    return a * b;
}
let multiplyByTwo = multiply.bind(this, 2) // 'this' is window object
let multiplyByTen = multiply.bind(this, 10)

console.log(multiplyByTwo)          >> OP >>    f   // 'f' means [Function] 
console.log(multiplyByTwo(4))       >> OP >>    8
console.log(multiplyByTen(4))       >> OP >>    40


MORE EXAMPLE TO BETTER UNDERSTAND
1.
var a = {
    name: 'a',
    say() {
        console.log('hello')
    }
}
console.log(a)      >> OP >> {name: 'a', say: ƒ}    // 'f' means [Function] 
a.say()             >> OP >> hello

2.
var b = {
    name: 'b',
    say() {
        console.log(this)
    }
}
b.say()             >> OP >> {name: 'b', say: f}

3.
var c = {
    name: 'c',
    say() {
        return function() {console.log(this)}
    }
}
c.say()             >> OP >> f () {console.log(this)} // we are returning a function
c.say()()           >> OP >> returns window object, which we don't want, we want the scope for c function, hence arraow function has arrived, for lexical scoping...this is Globally Scoped

4.
var d = {
    name: 'd',
    say() {
        return () => console.log(this)
    }
}
d.say()()           >> OP >> {name: 'd', say: ƒ}


CONTEXT vs SCOPE
Scope has to do with the the visibility of variables. It is achieved through the use of functions.
Context is related to objects. It refers to the object to which a function belongs. When you use the 'this' keyword, it refers to the object to which function belongs

** JAVASCRIPT TYPES
- only 7 types
number, boolean, string, undefined // special value in JS, null, Symbol('some text') // ES6, (PRIMITIVE)
Objects (NON-PRIMITIVE)

'undefined' vs 'null' >> undefined is absense of a definition. Used as default value when JS initialize a variable. Null is absense of value, there is no value.

Find data type using 'typeof'
** typeof null         >> OP >> 'object' // typeof null should be 'null', but it shows object, which is a bug in JavaScript
Symbol() are used for object properties

typeof {}               >> OP >> 'object'
typeof []               >> OP >> 'object'       // type of an array is also an object
typeof function() {}    >> OP >> 'function'     // 'function' is not a data type. It's an object as we can add property to function, like objects

** Primitive types are which data only represents a single value. Only store single value in memory.
In Non-Primitive type, like object, memory doesn't contain the actual value directly. Like an object, it has a reference/ pointer which has the values 

Standard Built-In Objects
these are not global objects. They come with the language. Like, NaN, Error, Symbol, Math, Date, Boolean, Number, String etc.


ARRAY
var array = [1, 2, 3]; 
// if we call a simple array like this. In JS, it works like
var array = {
    0: 1,
    1: 2,
    2: 3
}
typeof []       >> OP >> 'object'

Array.isArray([1,2,3])      >> OP >> true // Array is an object | dot notation | isArray is a property of Array object
Array.isArray({})      >> OP >> false


PASS BY REFERENCE vs PASS BY VALUE
Primitive types are pass by value & Objects are pass by reference
Pass by Value - copy the value & create the value somewhere else in memory

EXAMPLE
var a = 5;
var b = a; b++;
console.log(a); console.log(b);             >> OP >> 5 6


NOW, try the same for Objects
let obj1 = {name: 'Leo', password: '123'};
let obj2 = obj1;        // goes both ways, let obj1 = obj2;
obj2.password = 'easypeasy';

console.log(obj1); console.log(obj2);       >> OP >> {name: 'Leo', password: 'easypeasy'} {name: 'Leo', password: 'easypeasy'}

Note that both passwords are changed, which differs from the code we wrote. This happens due to Pass by Reference.
Objects stored in memory are passed by reference. Both objects, obj1 & obj2 are both pointing to memory, that contains the object values. Now while changing 'password', change 'password' in the object in memory, so both gets updated

AGAIN
let arr1 = [1,2,3,4,5]
let arr2 = arr1
arr2.push(6)
console.log(arr1); console.log(arr2);       >> OP >> [1,2,3,4,5,6] [1,2,3,4,5,6]

This is good for saving memory. Now if you dont want to passs by reference, use it like,
let arr2 = [].concat(arr1) // take an empty array & concat it  with arr1. concat means whatever arr1 has it pushes to arr2

for Objects, 
1.
let obj2 = Object.assign({}, obj1)   
2. Spread Operator
let obj3 = {...obj1}

** But, it doesn't work while object inside a object.
EXAMPLE
let obj1 = {
    a: 'a',
    b: 'b',
    c: {
        hello: 'world' // this is an object inside object
    }
}
let obj2 = {...obj1}

obj1.c.hello = 'test'
console.log(obj1)           >> OP >> ...hello: 'test'
console.log(obj2)           >> OP >> ...hello: 'test'

// each objects are passed by reference. Although we cloned the initial object, it cloned the first level only. Its called SHALLOW CLONE/ COPY - (In Shallow Copy, adding/ changing directly will only effect the copy. However, adding/ changing a deeply nested property will affect both original and copy)


** DEEP COPY - Opposite of SHALLOW COPY
let obj3 = JSON.parse(JSON.stringify(obj1)) // This is Deep Clone

obj1.c.hello = 'test'

console.log(obj1)           >> OP >> ...hello: 'test'
console.log(obj2)           >> OP >> ...hello: 'test'
console.log(obj3)           >> OP >> ...hello: 'world'

** WARNING in DEEP CLONING
This might have some performance implication. If the initial object (which you are copying) is a large/ deep one, it might take a lot time to clone everything.

COMPARE OBJECT
let obj1 = {a: 1, b: 2}
let obj2 = {a: 1, b: 2}
let eq = obj1 == obj2
console.log(eq)     >> OP >> false !! // but it should be true

The Fast & Limited way is to 'stringify' it. But we must have simple JSON style object & the ORDER of the properties in those objects must be same
JSON.stringify(obj1) === JSON.stringify(obj2)

// this would not work in this method
x = {a: 1, b: 2};
y = {b: 2, a: 1};

There are some deep level comparison here
https://stackoverflow.com/questions/1068834/object-comparison-in-javascript


** STRUCTURED CLONING
Due to some complications in Deep Copying (Recursive Data Structure, Built-in types like Map, Set, Date, RegExp etc will throw error in JSON.stringify, also discards functions), most browser have a new built-in function for deep copying
const myDeepCopyObject = structuredClone(myOriginalObject);


** TYPE COERCION
Type Coercion is the automatic conversion of values from one data type to another. All languages have Type Coercion. Only happens when '==' is used/ boolean is used ( if(1) {console.log(5)} // and it returns 5, because 1 is coerced to true )
1 == '1'        // returns true
when '===' is used, type coercion does not happen. Always stick to '==='

EXAMPLE
integer 1 double equals to/ type coreced to, 
Integer one, 
Boolean true, 
String 1,
array [1] // these are somehow confusing and tricky. So, avoid using '=='

AGAIN
-0 === +0 // returns true, technically these 2 operands are different, then came Object.is()

Object.is(-0, +0) // returns false

Object.is() vs '==='
+0, -0      >> false >> true
0, -0       >> false >> true
NaN, NaN    >> true >> false


** DYNAMIC vs STATIC TYPING
in a Statically Typed Language, we have to declare what type of variable we are going to write explicitly. Here Type Checking is done during Compile-time. 
in C++
int a;
a = 100;

for the same thing in JS, we go like, var a = 100
Dynamic Typed Language, they are little more smart, where we are not bound to this constraint. Here Type Checking is done during Run-time. TypeScript helps JavaScript to behave like a Static Typed Language.

Both have Pros & Cons - ST adds extra layer of complexity but usually prevents bugs and keeps errors from happening. DT is more flexible


** STRONG & WEAK TYPING
DYNAMIC & WEAKLY TYPED      - Perl, PHP, JavaScript
DYNAMIC & STRONGLY TYPED    - Erlang, GROOVY, Python, RUBY

STATIC & WEAKLY TYPED       - C, C++
STATIC & STRONGLY TYPED     - Java, C#, Scala, Haskell

EXAMPLE 
JavaScript, why it's a Dynamic Weakly Typed language
var a = "hello";
a + 17          >> OP >> "hello17" // this is Type Coercion, converts the entire thing into string

BUT, in a Dynamic Strongly Typed Language, it doesn't work like that


** STATIC TYPING/ TYPESCRIPT
in JS community, there are many options for Static Typing, Like Flow (developed by Facebook), Typescript (developed by Microsoft), ELM, ReasonML

FLOW -
Static type checkeer, which adds types to JavaScript by writing some codes, then putting it through BABEL Compiler, which spits out JS. It starts like 
// @flow
Flow comes prebuilt with React (create-react-app). 

TYPESCRIPT -
unlike Flow, it has it's own compiler. TypeScript is a superset of JavaScript that compiles to plain JavaScript. Angular is built with TS. TS is widely used among these options.
When to use TS - Project grows larger, app should be self-documenting, avoid bugs when new devs touch the codes


REASON ML -
Entire different language. has own compiler. Spits JS

ELM -
Entire different language. has own compiler. Spits JS. Same as Reason ML


** CLOSURES & PROTOTYPES
These are the 2 main pillars of JavaScript. As they are powerful and unique. 


FUNCTIONS AGAIN - are OBJECTS
When we invoke a function, we get 2 parameters automatically 'this' & 'arguments'
// Invoke
function one() { return 1; } one()      >> OP >> 1

// method/ function inside object - Invoke
const obj = {
    two() {
        return 2;
    }
}
obj.two()                               >> OP >> 2

// using call/ apply
one.call()

//function constructor - built-in JS Object
const four = new Function('return 4'); four()   >> OP >> 4
Also, you can pass parameter
const four = new Function('num', 'return num'); four(44)    >> OP >> 44

A Function is a Object. Inside it there are some codes and we can invoke it by using - () & it gets executed. 
It has an optional 'name' property, as there can be anonymous functions.
It has methods like, call(), apply(), bind() etc.
Functions are a special type of Objects in JS. Hence we can pass them around like objects, which has data. Like we pass objects contaiining data.


FIRST CLASS CITIZEN - FUNCTIONS
Why ? because we can pass functions around like data, watch these
1. Functions can be assigned to variables/ object properties
var stuff = function() {...}
2. Pass functions as arguments into another function
function a(fn) { // passing a function/ fn as a parameter to another function
    fn()
}
a(function() {
    console.log('Hello there !')
})
OP >> Hello there !
3. return functions as values from other functions
function b() {
    return c() {console.log('Inside c !')}
}
b()     >> OP >> [Function: c]
b()()   >> OP >> Inside c !
Also, var d = b()
d()     >> OP >> Inside c !

Just watch out for these,
for (let i = 0; i < 5; i++) {
    // everytime the loop runs, the function is initialized, which is not a good practise. Rather initialize it before the loop & invoke the function inside as per requirement
    function a() {...}
    a()
}

Again, when a parameter is not passed through a function, it throws ReferenceError. With ES6, we can give a default value to parameter. Like, function (param = 6) {...}


HIGHER ORDER FUNCTIONS
HOF is a function that accept other functions as parameter/ returns another function

EXAMPLE
Just creating a basic login functionality.

const giveAccessTo = (user) =>
    'Access granted to ' + user

function letUserLogin(user) {
    let array = [];
    for (let i = 0; i < 10000000000; i++) {
        array.push(i);
    }
    // These previous lines are added to delay the engine. Suppose, this is where the authentication happens.
    return giveAccessTo(user);
}

letUserLogin('Adam') // Now, when we run the function, after some delay/ the authentication process, access is granted to Adam.

Now, for ADMIN privileges, we could create another function, letAdminLogin(admin) BUT, to follow DRY method, we will use Higher Order Functions here.
const giveAccessTo = (name) => {
    console.log('Access granted to ' + name)
}
  
function authenticate(verify) {
    let array = [];
    for (let i = 0; i < 100000000; i++) {
      array.push(i)
    }
    return giveAccessTo(person.name)
}
  
function sing(person) {
    console.log('lalalalalalall my name is ' + person.name)
}
  
function letPerson(person, fn) { // using HOF here
    if (person.level === 'admin') {
      return fn(500000)
    } else if (person.level === 'user') {
      return fn(500)
    }
    // return giveAccessTo(person.name)
}
  
// letPerson({level: 'user', name: 'Tim'}, authenticate)
letPerson({level: 'user', name: 'Tim'}, sing)

EXAMPLE
const multiplyBy = function(num1) {
    return function(num2) {
        return num1 * num2;
    }
}
// we can even make it a one liner, using arrow function
multiplyByArrow = (num1) => (num2) => num1 * num2

const multiplyByTwo = multiplyBy(2);
const multiplyByFive = multiplyBy(5);
multiplyByTwo(5)            >> OP >> 10
multiplyByTwo(8)            >> OP >> 16
multiplyByArrow(4)(6)       >> OP >> 24


** CLOSURE
(Function + Lexical scope) - Closure is a combination of a function & lexical environment from which it was declared
Closure is a feature that allows inner functions to access the outer scope of a function. It makes it possible for a function to have "private" variables.

EXAMPLE
function a() {
  let grandpa = 'grandpa'
  return function b() {
    let father = 'father'
    return function c() {
      let son = 'son'
      return `${grandpa} > ${father} > ${son}`
    }
  }
}
// a() & b() are higher order functions. As they are returning another functions. c() is just a normal function

a()         >> OP >> [Function b]
b()         >> OP >> ReferenceError...
a()()       >> OP >> [Function c]
a()()()     >> OP >> 'grandpa > father > son'
NOW, it is expected but, how did c() remember what a() and b() has, it should be removed from the stack and garbage collected. This is where 'Closure' comes.

It only works when referenced in child functions. Like, there were references for 'grandpa', 'father' in c(). SO these were kept in Closure but, if there was, let random = 2342342343, was also inside b(), it would be Garbage Collected as there is no reference of 'random' further/ in c()

EXAMPLE,
function boo(string) {
    return function(name) {
        return function(name2) {
            console.log(`${string} ${name} ${name2}`)
        }
    }
}
OR
const boo = (string) => (name) => (name2) => console.log(`${string} ${name} ${name2}`)

boo('hi')('Tim')('Becca')       >> OP >> hi Tim Becca


CLOSURES ARE MEMORY EFFICIENT (if written properly)
there is a heavy duty function, where a lot of work is happening/ a big array of 10,000 contents is being created. Now, if the function is called multiple times, the big array is going to be created each times too. We can solve this with Closure

function heavyDuty(index) {
    const bigArray = new Array(10000).fill('content')
    console.log('Every time array is created, this logs')

    return bigArray[index]
    // change the last line to use Closure
    return function(index) {
        return bigArray[index]
    }
}

CLOSURES & ENCAPSULATION
Closures enable the creation of private variables. By defining variables within a function, you can control their accessibility and protect them from external interference.

** EXAMPLE
const array = [1,2,3,4];
for (var i = 0; i < array.length; i++) {
    setTimeout(() => {
        console.log('Im at index '+i)
    }, 2000)
}
OP >> Im at index 4 // it shows 4 times
BUT, if used 'let' instead of 'var', it would show, Im at index 0, Im at index 1...
ALSO, we could use 'var' & 'closures' here, by calling & instantly invoking a function

// calling
function() {
...codes
}

// invoking it
(function(closureI) {
    setTimeout(() => {
        console.log('Im at index '+closureI)
    }, 2000)
})(i)


** PROTOTYPES (PROTOTYPAL INHERITANCE)
Inheritance - An object getting access to properties & methods of another object
Prototypes are the mechanism by which JavaScript objects inherit features from one another.

Every object in JavaScript has a built-in property, which is called its prototype. The prototype is itself an object, so the prototype will have its own prototype, making what's called a prototype chain. The chain ends when we reach a prototype that has null for its own prototype.

EXAMPLE
const arr = [];
arr.__proto__ // proto is prototype chain here

// this is used to go up to the prototype chain. like arr > Array[] > Object{}. now we are accessing Array[] by using __proto__. If it's used again, we would go another level up & access Object{}

arr.__proto__.__proto__ 

// here we can access many properties of object{}. This is how we can access any properties/ methods that an object has. Like toString(). So, arr.toString() > OP > "" // converts the empty array to string

EXAMPLE
let dragon = {
    name: 'Jean',
    fire: true,
    fight() {
        return 5
    },
    sing() {
        return `I am ${this.name}, the breather of fire`;
    }
}

let lizard = {
    name: 'Kiki',
    fight() {
        return 1
    }
}

NOW, if we borrow methods from dragon object, we could do that with bind()
const singingLizard = dragon.sing.bind(lizard)
console.log(singingLizard) > OP > I am Kiki, the breather of fire

NOW, if the sing() method rely on fire property, the bind() code wont work (undefined). Like,
sing() {
    if(this.fire) {
        return `I am ${this.name}, the breather of fire`;
    }
}

This is where Prototypal Inheritance comes in. Where lizard can inherit methods & properties of dragon.
lizard.__proto__ = dragon // going up the prototype chain
lizard.sing()       // I am Kiki, the breather of fire
lizard.fire         // true
lizard.fight()      // 1, this is not replaced
dragon.isPrototypeOf(lizard)    // true

// Going through properties
lizard.__proto__ = dragon
for (let prop in lizard) { // loop throught the properties of lizard
    console.log('All properties lizard has>>')
    console.log(prop)               >> name fight fire sing

    if (lizard.hasOwnProperty(prop)) {
        console.log(prop)           >> name fight
    }
}

** REMEMBER, while using lizard.hasOwnProperty(), if JS engine doesnt find the property (hasOwnProperty) on that object (lizard), it goes up the prototype chain. HERE, hasOwnProperty() is not part of lizard object, so it goes up the prototype chain to dragon, upto the base object & finds hasOwnProperty() & uses it

Prototype chain & Scope chain are different

when not found in Prototype chain for properties/ methods
lizard.ahaha() > OP > says TypeError: ahaha not a function
lizard.ahaha   > OP > undefined

// when its passed the base object, obj.__proto__.__proto__ > OP > null
this is null pointer. nothing is there, when passed the base object

// a function is also a object (special type of object. Callable Object) in JS. So, a.hasOwnProperty('name') > OP > true
whereas, a.hasOwnProperty('call') returns false, same as bind & apply returns false

NOW, for a function,
** multiplyBy5() this custom function is linked to 'Base Function' using __proto__ pointer/ keyword. 
** __proto__ goes up the prototype chain to base function & points to the prototype of it. (__proto__ and prototype are different)
multiplyBy5().__proto__ >> Base Function.__proto__ >> Base object.__proto__ >> null (Null pointer here)

let human = {
    mortal: true
}
let socrates = Object.create(human) // socrates is created using object.create, the prototype chain. instead of using __proto__
socrates.age = 65
console.log(socrates.age)       >> 65
console.log(socrates.mortal)    >> true
console.log(human.isPrototypeOf(socrates))      >> true

Only Functions have the prototype property

// EXAMPLE 1
add lastYear() to Date constructor, when a new date is passed, it should show (year - 1) in YYYY format
new Date('1900-10-10')

Date.prototype      // this shows the properties the Date object has access to
Date.prototype.lastYear = function() {          // adding lastYear to the properties. Using arrow function wont work here. 'this' will be lexically scoped in arrow function
    return this.getFullYear() - 1
}
new Date('1900-10-10').lastYear()       >> OP >> 1899
new Date().lastYear()                   >> OP >> 2023

// EXAMPLE 2
array mapping
const arr = [4, 9, 25, 36, 64];
console.log(arr.map(Math.sqrt))         >> OP >> 2, 3, 5, 6, 8
console.log(arr.map(myFunc))            >> OP >> 40, 90, 250, 360, 640

function myFunc(num) {
    return num * 10
}

// EXAMPLE 3
Modify .map() to print 'extra' at end of each item

Array.prototype.map = function() {
    let arr = [];
    for (let i = 0; i < this.length; i++) {
        arr.push(this[i] + 'extra')
    }
    return arr
}
console.log([1,2,3].map())              >> OP >> 1extra, 2extra, 3extra
WELL, this is quite dangerous. As were updating the map() function's functionality and the entire script where map is used might be broken too.



** OOP - OBJECT ORIENTED PROGRAMMING (this, new keyword, Prototype, ES6 class, Inheritance, Object.create(), Private vs public, 4 principles of OOP)
WHY ? Clear codes, Easy to extend & maintain, memory efficient & to follow DRY method

this keyword, new keyword, Prototype, ES6 classes, Java, Inheritance, Object_create(), Private vs Public, 4 principles of OOP
2 types mainly - class based & prototype based 
OOP is mainly modelling real world objects & relationships

FACTORY FUNCTION
Suppose, there is const elf = {...}, with some properties & methods like, name, weapon, attack() etc. Now, when we need another elf, we will use const elf2 = {...}, const elf3 = {...} etc. We need encapsulation here. So, instead, we can do is

function createElf(name, weapon) {
    return {
        name,         // in ES6, if the property & values are same, like name: name, weapon: weapon, we can use it like...
        weapon,
        attack() {
            return 'attack with '+ weapon
        }
    }
}
const peter = createElf('Peter', 'stones')
peter.attack()          >> OP >> attack with stones

NOW, attack() functionality is same & will be stored in memory everytime a new elf is created, to solve that...
1. remove attack() from createElf()
2. const elfFunction = {
    attack() {
        return 'attack with '+ this.weapon
    }
}
3. peter.attack = elfFunction.attack

NOW, to clean this up, we could use Object.create()
function createElf(name, weapon) {
    let newElf = Object.create(elfFunction)
    newElf.name = name;
    newElf.weapon = weapon;
    return newElf;
}

console.log(peter.attack())         >> OP >> sttack with stones

** CONSTRUCTOR FUNCTION
function Elf(name, weapon) {
    this.name = name
    this.weapon = weapon
}
// we are not returning anything here. we are constructing/ creating en elf using 'this' 
// to use constructor functions, we use 'new' keyword. 'new' returns the object for us automatically. Like, new Date()
// any function which is invoked with 'new' keyword, is called 'Constructor Function'
// Date() is a constructor function. As a rule, not mandetory though, constructor functions should start with 'Caps'

const sam = new Elf('Sam', 'sticks')
sam.name            >> OP >> Sam

FUNCTION CONSTRUCTOR
const Sum = new Function('a', 'b', 'return a + b');
console.log(Sum(2, 6));     >> OP >> 8

const Elf1 = new Function('name', 'weapon', 'this.name = name; this.weapon = weapon;')
const sarah = new Elf1('Sarah', 'fireworks')
console.log(sarah)          >> OP >> {name: 'Sarah', weapon: 'fireworks'}
// the 'new' keyword points 'this' to the object (Sum/ Elf1 etc.) 'this' now becomes Sum/ Elf1

// AGAIN

function Elf(name, weapon) {
    console.log(this)               >> OP >> Elf {}
    this.name = name
    this.weapon = weapon
    console.log(this)               >> OP >> Elf {name: 'Peter', weapon: 'stones'}
}
Elf.prototype.attack = function() {
    return 'attack with '+this.weapon
}
const peter = new Elf('Peter', 'stones')
console.log(peter.attack())         >> OP >> attack with stones
const jack = new Elf('Jack', 'sticks')
console.log(jack.attack())          >> OP >> attack with sticks


* type of 'this'
// new binding this
function Person(name, age) {
    this.name = name; this.age = age;
}
const person1 = new Person('Sam', 55)
person1             >> OP >> Person { name: 'Sam', age: 55 }

// implicit binding
const person2 = {
    name: 'Karen',
    age: 55,
    hi() {
        console.log('hi ' + this.name)
    }
}

// ecplicit binding (explicitely binding 'this' keyword with window object)
const person3 = {
    name: 'Xavier',
    hi: function() {
        console.log('hi ' + this.setTimeout)
    }.bind(window)      
}
person3.hi()        >> OP >> setTimeout() {[native code]}

// arrow function
const person4 = {
    name: 'Josh',
    hi: function() {
        var inner() = () => {
            console.log('hi ' + this.name)
        }
        return inner()
    }
}
person4.hi()        >> OP >> hi Josh


** ES6 class
class is a blueprint of what we want to create
class Elf {
    constructor(name, weapon) {
        this.name = name
        this.weapon = weapon
    }

    attack() {
        return 'attack with '+this.weapon
    }
}

// instance/ object
const peter = new Elf('Peter', 'stones')    // 'peter' is an instance of 'Elf'
console.log(peter instanceof Elf)           // true
// class is actually 'prototypal inheritance' in disguise. (also called Pseudo classical inheritance)

class vs Object.create()
new X is Object.create(X.prototype) with additionally running the constructor function. (And giving the constructor the chance to return the actual object that should be the result of the expression instead of this.)


** INHERITANCE
1. problem before 'extends'
after class Elf...
const fiona = new Elf('Fiona', 'ninja stars')
console.log(fiona)              >> OP >> { name : 'Fiona', weapon : 'ninja stars' }
const ogre = {...fiona} // using spread operator to clone fiona
console.log(ogre)               >> OP >> { name : 'Fiona', weapon : 'ninja stars' }

console.log(fiona === ogre)     >> OP >> false
// these objects are not referencing the same place in memory
console.log(fiona.__proto__)    >> OP >> Elf {} // base object is pointed here
console.log(ogre.__proto__)     >> OP >> {} // the prototypal chain is lost here
agre.attck()                    >> OP >> doesnt work as well

2. after using 'extends', updatign the code a little
class Character {
    constructor(name, weapon) {
        this.name = name
        this.weapon = weapon
    }
    attack() {
        return 'attack with '+ this.weapon
    }
}
class Elf extends Character {       // this means, set __proto__ of Elf to Character, so Elf now has a prototype chain upto Character

}
const fiona = new Elf('Fiona', 'ninja stars')
console.log(fiona)              >> OP >> Elf { name : 'Fiona', weapon : 'ninja stars' }

// ** NOW, if we want to use a method inside 'Elf' class
class Elf extends Character {
    constructor(name, weapon, type) {
        super(name, weapon) // in PHP, this is like, parent::__construct()
        this.type = type
    }
}
const dolby = new Elf('Dolby', 'cloth', 'house')
console.log(dolby)              >> OP >> Elf { name : 'Dolby', weapon : 'cloth', type : 'house' }
console.log(dolby.attack())     >> OP >> attack with cloth

// AGAIN

class Ogre extends Cahracter {
    constructor(name, weapon, color) {
        super(name, weapon)
        this.color = color
    }

    makeFort() {
        return 'Strongest fort is made'
    }
}
const shrek = new Ogre('Shrek', 'club', 'green')
shrek                                       >> OP >> Ogre { name : 'Shrek', weapon : 'club', color : 'green' }
shrek.makeFort()                            >> OP >> Strongest fort is made

// in JS, everything is an object. like this 'Ogre', which is defined as a class, but is an object
So, as an object, 'Ogre' has some built-in properties and makeFort() is a custom one.
Its like, Ogre.prototype.makeFort()

Ogre.isPrototypeOf(shrek)                   >> OP >> false
Ogre.prototype.isPrototypeOf(shrek)         >> OP >> true       // Ogre.prototype contains all the properties & methods
Character.prototype.isPrototypeOf(Ogre.prototype)   >> OP >> true

dolby instanceof Elf                        >> OP >> true
dolby instanceof Ogre                       >> OP >> false
dolby instanceof Cahracter                  >> OP >> true


** PRIVATE & PUBLIC FIELDS
before private fields were introduced in JS, '_' was used like '_attack()' to identify a properties/ methods as private, which didnt do anything rather than just identify

later, in ES2022, using '#' before properties/ methods made them 'private'
class Employee {
    #name = "Test"; // private field
    setName(name) {
        this.#name = name;
    }
}
const emp = new Employee();
emp.#name = 'New'; // error
emp.setName('New'); // ok

class Employee {
    #name = "Test";
    constructor(name) {
        this.#setName(name) // ok
    }
    #setName(name) { // Private method
        this.#name = name;
    }
}
const emp = new Employee('New'); // ok
emp.#setName('New'); // error


** OOP in React
class Toggle extends React.Component {
    constructor(props) {
        super(props)
        this.state = {isToggleOn: true}
    }

    handleCLick() {
        ...
    }

    render() {
        ...
    }
}


** 4 PILLARS OF OOP
ENCAPSULATION
Before OOP, in procedural programming, we used functions, data update etc and in OOP, we started using class, objects
in ENCAPSULATION we wrap related codes like in a box. And the boxes interact with each others

ABSTRACTION
incomplete/ hiding the complexity from users. Also the private keywords are useful in here

INHERITANCE
by using this, we avoid rewriting same code and save memory space

POLYMORPHISM
means many forms. its like, the ability to call the same methods for different objects but each objects responds in different way

* METHOD OVERRIDING
when a child class inherits some method from the parent class but redefines it on its own context
EX
class Test1 {
    describe() {
        ...
    }
}
class Test2 extends Test1 {
    describe() {
        ...
    }
}
test1.describe()
test2.describe()
OP >> different results each time


* METHOD OVERLOADING
when two methods bears the same name but differs in type or the no. of arguments that are passed into the methods
JS doesnt support method overloading, but can be faked
EX
class Polygon {
    area(sideA, sideB) {
        console.log(sideA*sideB)
    }
    area(side) {
        console.log(side * side)
    }
}

const polygon = new Polygon()
polygon.area(5, 7)          >> OP >> 25 // wrong
polygon.area(6)             >> OP >> 36

EX
const test = new Test()
const test2 = new Test2()
test.attack('param')        >> OP >> working param
test2.attack()              >> OP >> working without param


ANOTHER EX
class Queen extends Character {
    attack() {
        console.log(super.attack())
        return `More texts`
    }
}
queen.attack()              >> OP >> Character class texts. More texts


FUNCTIONAL PROGRAMMING - (Currying, Partial application, Pure functions, Referential transparency, Compose, Pipe)
Packaging our codes to seperate chunks and each chunk concerns about the one thing that it's good at. Uses mainly data & functions
Idea of seperating data & functions

WHY ? Clear codes, Easy to extend & maintain, memory efficient & to follow DRY method (Same as OOP)

** PURE FUNCTIONS
Pillar of Functional Programming
2 things to follow - 
always must return same output given the same input & cannot modify anything outside itself/ no side effects

EXAMPLE
This following code has side effect
const array = [1,2,3]

function mutateArray(arr) {
    arr.pop()               // not returning anything. just a basic method
}

function populateArray(arr) {
    arr.forEach(item => {
        arr.push(11)
    })
}

mutateArray(array)
populateArray(array)
console.log(array)      >> OP >> 1,2,11,11

NOW, watch this code has no side effects
const array = [1,2,3]

function mutateArray(arr) {
    const newArray = [].concat(arr)
    // not using, newArray = arr like this, instead of pointing both arrays to the same location, we have a new location pointing to the memory

    newArray.pop()
    return newArray
}

function populateArray(arr) {
    return arr.map(item => item * 2)
}

const array2 = mutateArray(array)
const array3 = populateArray(array)
console.log(array, array2, array3)
OP >> [1,2,3] [1,2] [2,4,6]


Pure functions also must maintain, Input same as output, which most the functions mostly does. like,
function a(num1, num2) {return num1 + num2}
function b(num) {return num * 2}
a(4, 3)         >> OP >> 7      // this is always 7, no matter how many times we run it
b(a(4, 3))      >> OP >> 14     // always same
NOW, if
b(7)            >> OP >> 14     // we are replacing a(4, 3) with 7 directly, meaning no matter the input, output is always same, this is called Referential Transparency

These functions doesnt also have any side effects.

Not every functions can be pure. But there are some things to maintain in Functional programming
a single function should do a Single task
should have 'return' statement
should be Pure
no Shared state with other functions
Immutable state, donot modify global state
Composable, 
Predictable


IDEMPOTENT
ability to make multiple identical requests, and only have the changes applied once
Like, while deleting a user from database, if done with a single request/ multiple request with userId, the user will be deleted only once


IMPERATIVE vs DECLARATIVE
Imperative code tells the machine what to do & how to do it (like how computers work)
Declarative code tells the machine what to do & what should happen (like how humans work)
jQuery is imperative. React is declarative

EX - Imperative
for (let i = 0; i < 10; i++) {
    console.log(i)
}
EX - Declarative
[1,2,3,4,5,6,7,8,9,10].forEach(item => console.log(item))


IMMUTABILITY
means, not changing/ mutating data & state. Instead making copy of the state as required & return them
EX
const obj = {name: 'Andrei'}
function clone(obj) {
    return {...obj}     // this is pure
}
function updateName(obj) {
    const obj2 = clone(obj)
    obj2.name = 'Nana'
    return obj2
}
const updatedObj = updateName(obj)
console.log(obj, updatedObj)    >> OP >> { name : 'Andrei' } { name : 'Nana' }


HOF - HIGHER ORDER FUNCTIONS & CLOSURES, review again
in JS, functions are first class citizen, means we can have HOF & closures
HOF means one/ more functions as arguments OR returns a function as result as callback

EX 1
const hof = () => () => 5
hof()       >> OP >> FUNCTION
hof()()     >> OP >> 5 // function returning a function

EX 2
const hof = (fn) => fn(5)
hof(function a(x) {return x})   >> OP >> 5 // parameter of hof is taking a function

Closure
to access variable outside function scope
here in FP, it should be like, the main variable should not be touched/ the value cant be modified
const closure = function() {
    let count = 55;
    return function getCounter() {
        return count++;
    }
}

const getCounter = closure()
getCounter()
getCounter()    >> OP >> 57


** CURRYING
breaking down a function that takes multiple arguments, into series of functions that takes one argument each
EX
const multiply = (a, b) => a * b
multiply(3, 4)              >> OP >> 12

now, using currying into this function
const curriedMultiply = (a) => (b) => a * b
curriedMultiply(3)(4)       >> OP >> 12

WHY ? multiple utility functions can be created from this, we can run different parts of a function
EX
const curriedMultiplyBy5 = curriedMultiply(5)
curriedMultiplyBy5(4)       >> OP >> 20
curriedMultiplyBy5(5)       >> OP >> 25
curriedMultiplyBy5(6)       >> OP >> 30


** PARTIAL APPLICATION
partially apply a function, a process of producing a function with smaller no of parameters
EX
const multiply = (a, b, c) => a * b * c

// converting into curried
const curriedMultiply = (a) => (b) => (c) => a * b * c
curriedMultiply(5)(4)(10)               >> OP >> 200

// converting into partial
const multiply = (a, b, c) => a * b * c
const partialMultiply = multiply.bind(null, 5)
partialMultiply(4, 10)                  >> OP >> 200

// Currying vs Partial Application
breaks down function with multiple arguments into series of unary functions || creats new function with fewer arguments


** MEMOIZATION CACHING
caching is a way of storing values for later use (ised in DYNAMIC PROGRAMMING)
(EX - when u goto school and need a pencil, u take it from the small bagpack u carry, along pencils and others. u dont goto home again to bring it)

Memoization is a form of caching, used in Dynamic programming, that involves caching the return value of a function based on its parameters. If the params donot changed, they are memoized
WHY ? when performing an operation, if its needed to run for multiple time, we could optimize it so that it would be faster each time.

** EXAMPLE
suppose, this is a regular long operation
function addTo80(n) {
    console.log('more longer process');
    return n + 80;
}
addTo80(5)
addTo80(5)
addTo80(5)
addTo80(5)
OP >> more longer process...more longer process...more longer process...more longer process...80 (something like this)

NOW, UPDATING THE FUNCTION
let cache = {}; // poluting global scope though

function memoizedAddTo80(n) {
    if (n in cache) {
        return cache[n];
    } else {
        cache[n] = n + 80
        return cache[n];
    }
}

memoizedAddTo80(5)  >> 85
** after running it first time, cache variable changes like
cache = {
    5: 85
}
which is happening in else part
again, for next time, memoizedAddTo80(5), it goes to the if statement & simply does a property access
now its super fast with a Hash Table (Hash Tables are a data structure that allow you to create a list of paired values & retrieve a certain value by using the key)

// to avoid that Global scope problem. we will use closure
function memoizedAddTo80() {
    let cache = {}

    return function(n) {
        if (n in cache) {
            return cache[n];
        } else {
            cache[n] = n + 80
            return cache[n];
        }
    }
}
// now to use it
const memoized = memoizedAddTo80()
memoized(5)     >> OP >> 85
memoized(5)     >> OP >> 85
memoized(6)     >> OP >> 86


** COMPOSE (FUNCTION COMPOSITION) & PIPE
Function composition - combine multiple functions into a single one
Suppose, we need a function to multiply 3 & -50, also need the absolute format (positive), these are 2 operations. we need to compose them together
JS library, Ramda, has inbuilt function 'compose'. But here we will build this

EXAMPLE
const compose = (f, g) => (data) => f(g(data)) // compose is right ot left
const multiplyBy3 = (num) => num * 3
const makePositive = (num) => Math.abs(num)
const multiplyBy3AndAbsolute = compose(multiplyBy3, makePositive)

multiplyBy3AndAbsolute(-50)     >> OP >> 150

PIPE (Left to right)
const compose = (f, g) => (data) => g(f(data)) // Oppositeof compose

Generic function example    - fn1(fn2(fn3(50)))
with compose we could do    - compose(fn1, fn2, fn3)(50)
with pipe we could do       - pipe(fn3, fn2, fn1)(50)

ARITY - no of args a function takes. that's it.
Remember to use fewer no of args in functions to make them more flexible


** EXERCISE CART
1. Add items to cart        2. Add 3% tax       3. Buy item, cart > purchase        4. Empty cart

cont user = {
    name: 'Kim',
    active: true,
    cart: [],
    purchases: []
}

const compose = (f, g) => (...args) => f(g(...args));
purchaseItem(
    emprtCart,
    buyItem,
    applyTaxToCart,
    addItemToCart
)(user, {name: 'laptop', price: 200})

function purchaseItem(...fns) {
    return fns.reduce(compose)
}

function addItemToCart(user, item) {

}

...TO BE CONTINUED


** COMPOSITION vs INHERITANCE
combine multiple functions to single || pass characteristics from parent to child
used in FP || OOP

* PROBLEM (Tight Coupling Problem, Fragile Base CLass Problem, Hierarchy problem)
In Inheritance, a class has some properties & methods, when extended the child classes are going to have those properties & methods too. 

Now the problem is, we are binding data (this class has some specifed properties & methods). We can always add more methods/ update existing classes of the parent class but the child class will inherit them too, this is called TIGHT COUPLING PROBLEM. So keeping the code DRY also creates a problem. So changing the code in one place can have a ripling effect into the other extending classes. This is FRAGILE BASE CLASS PROBLEM

Also, we are using a simple setup here. Base/ Parent class, the extending child classes. So the HIERARCHY PROBLEM appears when somehow we try to update the hierarchy due to client requiremt or other reason (a junior class might level up & goes up the hierarchy)

Also, in case of deep hierarchies, childClass4 will have many unwanted properties/ methods from childClass1/2/3. Due to this Tightly Coupled concept, they inherit multiple classes


Use Composition instead. Suppose, we need to make a sandwich, instead of inheriting all properties from a super-sandwich class, we can assemble it from ingredients.
const bread = {
    type: 'whole wheat',
    toasted: true
};
const cheese = {
    type: 'cheddar',
    sliced: true
};
const meat = {
    type: 'turkey',
    grilled: false
};
  
// Sandwich object composed of ingredients
const sandwich = {
    bread: bread,
    cheese: cheese,
    meat: meat,
    eat: function() {
        console.log("Nom nom nom!");
    }
};

// Now, you can make a sandwich and eat it!
sandwich.eat();
>> OP >> Nom nom nom!

Composition allows to build complex objects from simpler parts, making code more modular and easier to understand. It's like LEGO bricks — we can create various structures by snapping different pieces together.

Same thing using class & inheritance

class Food {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`Eating ${this.name}`)
    }
}
class Sandwich extends Food {
    constructor(name, filling) {
        super(name)
        this.filling = filling
    }

    eat() {
        console.log(`Eating ${this.name} with ${this.filling}`)
    }
}

// creating instance
const simpleSandwich = new Sandwich('Simple sandwich', 'ham and cheese')
simpleSandwich.eat()
>> OP >> Eating Simple sandwich with ham and cheese

** Now, the DIFFERENCE
1. Inheritance: With inheritance, the Sandwich class inherits the behavior (methods) and properties of the superclass (Food). This means that Sandwich is a type of Food.
2. Composition: In composition, we build the Sandwich object by combining smaller objects (ingredients). The Sandwich object contains these smaller objects but does not inherit their behavior. Each ingredient is its own standalone entity.

** So, why Composition over Inheritance
Composition allows to build smaller & more focused components
Code becomes easier to understand as components have clear responsibility
we could create library of reusable components that can be used accross different parts of application
inheritance can lead to 'Fragile base class' problem, where changes to a super class, can affect subclasses
composition promotes encapsulation, as each component hides their implementation details and expose only necessary interface

Overall, while inheritance has its uses, composition is often preferred in JavaScript and other dynamic languages for its flexibility, modularity, and ease of maintenance. It encourages a more component-based approach to design, which can lead to more robust and scalable applications.


** FP vs OOP
Many operations on fixed data || few operations on common data
stateless (we dont modify states) || statefull
pure functions, no side effects || there are side effects, methods manipulate their internal states
declarative, what we want || imperative, how we want it
good for processing large data for applications || less operations but many things/ characters
data & behaviour are distinctly different things & should be kept seperately for clarity || bring together data & behaviors in objects/ class


** ASYNCHRONOUS JAVASCRIPT (Web APIs, Async/ await, Callbacks, Microtask queue/ Job queue/ Promise queue, Task queue/ Callback queue, Promises, Event loop)
Asynchronous programming is a concept that allows code to run in the background without breaking execution of other code.
Now, JS is Single-threaded language/ runs Synchronous code (Means one set of instruction is completed at a time). 

* JS Runtime/ Web API
the Web browser works in the background, when the synchronous JS code is running. It does this by using WEB API (Web API comes with browser, amde with low level languages like C++).

WEB API is used to send HTTP Request (fetch), listen to DOM event, delay executions (SetTimeout), used for Caching, Database Storage in browser (indexedDB) etc. (To check simply goto console and type 'window')

WEB APIs are ASYNCHRONOUS - means, we can instruct the APIs to do something in the background and return data once done. Meanwhile, we can continue working on JS Call Stack & execute functions

WEB API runs only when the stack is empty & the entire file is completed running


Example
setTimeout(()=>{console.log('1', 'is the loneliest number')}, 0)
setTimeout(()=>{console.log('2', 'can be as bad as one')}, 10)
Promise.resolve('hi').then((data)=> console.log('2', data))
console.log('3','is a crowd')

OP
3 is a crowd
2 hi
1 is the loneliest number
2 can be as bad as one

setTimeout() is an asynchronous function. Part of Web API
Other parts of Web API are DOM, ajax/fetch(), setTimeout()

In every browser, JS has Runtime it's environment. Which are
Call stack | Web API | Callback Queue | Event Loop

Generally JS engine puts everything on CALL STACK
Once it sees something 'asynchronous'/ part of web API/ timeout 
> sends it to WEB API, which does something in the background
> when done, it adds the result (the function we need to invoke) into CALLBACK QUEUE
> EVENT LOOP checks if the callstack is empty & entire JS file is read once & if its empty, it pushes it into 'Call Stack'
> the EVENT LOOP simply monitors the call stack & the callback queue


** How does JS work ?
** Difference between synchronous and asynchronous
** JS is single threaded language that can be non-blocking
discussion on these questions

* What is a program
does 2 simple things 
> allocate memory (for variables or having files on computer)
> parse and execute scripts (means read and run commands)

for JS, in chrome, v8 engine runs JS code & changes code into machine. Now, the engine consists of 2 parts (memory heap & call stack)
Remember, creating global variables creates 'Memory leak'. As memory is limited
Call stack - reads & executes code

Other languages can have multiple call stack, those are called 'Multi threaded'. But JS is keeping it simple as a single threaded language. Only one thing to worry about. Multi threaded langauges face a common problem, Deadlock (a condition in which two or more threads are blocked (hung) forever because they are waiting for each other)

Also in JS, Stack overflow & Memory Leak happens. 
creating a stack overflow by recursion (means when a function calls itself)
function foo() {
    foo()
}
foo()

Again, in JS, when a bigger task is being executed the others tasks are blocked. JS can be non-blocking. which means that the language does not wait for a previous instruction to finish executing before it moves to the next one
in JS, we can simply convert synchronous code to asynchronous code
console.log('1')
console.log('2', 'bigger task')
console.log('3')

OP > 1 2 3

TO

console.log('1')
setTimeout(() => {
    console.log('2')
}, 10)
console.log('3')

OP > 1 3 2

Another good example is, calling & texting, calling is synchronous. you have to wait till the other person picks up. you are not doing anything in the meantime. While in texting, after sending the desired text, you can do you anything you want and when the other person is reads it, they will respond you. you can do anything in the meantime


** ARROW FUNCTION

// 1 Named function with multiple parameters
function sum(a, b) {
    return a + b
}

// Conversion
let sum2 = (a, b) => {
    return a + b
}

// one liner
let sum2 = (a, b) => a + b


// 2 Named function with one parameter
function isPositive(number) {
    return number >= 0
}

// Conversion
let isPositive2 = number => number >= 0


// 3 Named function with no parameter
function randomNumber() {
    return Math.random
}

// Conversion
let randomNumber2 = () => Math.random

* for these examples, the arrow function trick doesn't shine much until using with anonymous functions and 'this' keyword

// 4 Anonymous function, function with no name
document.addEventListner('click', function() {
    console.log('Clicked')
})

// Conversion
document.addEventListner('click', () => {
    console.log('Clicked')
})

// One liner
document.addEventListner('click', () => console.log('Clicked'))


// 5 Arrow function inside class, using 'this'
class Person {
    constructor(name) {
        this.name = name
    }
    personWithFunction() {
        setTimeout(function() {
            console.log('Function> '+this.name)
        }, 100)
    }
    personWithArrow() {
        setTimeout(() => {
            console.log('Arrow> '+this.name)
        }, 100)
    }
}
let person = new Person('Suvajit')
person.personWithFunction()
person.personWithArrow()

OP >>
Function>
Arrow> Suvajit

note, 'this.name' doesn't work inside 'regular function' here
In normal functions, 'this' variable is created which references the objects that call them. Like the window, document, button etc



** PROMISES
Promise is an object that represents completion or failure of asynchronous operation and it's returning value.
> has 3 states - resolved, rejected, pending
> almost same as 'callbacks' but more powerfull (better error handling by using catch(), provides chaining method with then())
> it's new feature in ES6
> just like a promise in real life. When we promise to do something, then the results are either completed (resolved) or failed (rejected). if resolved > 'then', if failed get errors in 'catch'

EXAMPLE 1 - Basic promise
const promise = new Promise((resolve, reject) => {
    if(true) {
        resolve('It works')
    } else {
        reject('Something happened')
    }
})

promise.then(result => console.log(result))
OP >> It works

EXAMPLE 2 - Catch error
const promise = new Promise((resolve, reject) => {
    if(false) {
        resolve('It works')
    } else {
        reject('Something happened')
    }
})

promise
    .then(result => console.log(result))
    .catch(() => console.log('Error!'))
OP >> Error!

EXAMPLE 3 - Basic async job
let promiseOne = new Promise()
>
let promiseOne = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log(`some asynchronous task`)
        resolve()
    }, 1000)
})
promiseOne.then(() => {
    console.log(`after resolved`)
})
OP >>
some asynchronous task
after resolved

EXAMPLE 4 - then & catch
let p = new Promise( (resolve, reject) => {
    let a =  1 + 1;

    if(a == 2) {
        resolve('Success');
    } else {
        resolve('Failure');
    }
} )

// if the code is resolved, 'then' block works. 'catch' block is used to catch errors/ failed state

p.then((message) => {
    console.log('This is inside then > ' + message)
}).catch((message) => {
    console.log('This is inside catch > ' + message)
})

OP >> This is inside then > Success

Promises are great while doing asynchronous work (like downloading an image from a diff server). we can catch resolved/ rejected states
We can use multiple 'then's as required

HOW IT WORKS
We create a promise > We tell it what we want, when it succeeds and what we want, when it fails >
Then we process the request, use 'then' when it succeeds and 'catch' when it fails


MULTIPLE PROMISES *
const promise1 = new Promise((resolve, reject) => {
    resolve('promise 1 resolved')
})
const promise2...
const promise3...

Promise.all([
    promise1,
    promise2,
    promise3
]).then((messages) => {
    console.log(messages)
}).catch((errors) => {
    console.log(errors)
})

OP > array of promises >
[
    "promise 1 resolved",
    "promise 2 resolved",
    "promise 3 resolved"
]

Promise.race([
    ... same as Promise.all() but unlike returning an array it returns the first promise, then the second...
])

EXAMPLE 5 - Real-life example
const urls = [
    'https://jsonplaceholder.typicode.com/posts',
    'https://jsonplaceholder.typicode.com/todos',
    'https://jsonplaceholder.typicode.com/comments'
]

Promise.all(urls.map(url => {       
    return fetch(url)
            .then(resp => resp.json())
            .catch(() => console.log('Error connecting to server !'))
})).then(results => {
    console.log(results[0])
    console.log(results[1])
    console.log(results[2])
}).catch(() => console.log('ERROR !'))

NOTES,
map()   >   modifies each element of an array & returns the new array
fetch() >   makes http request, promise-based
json()  >   takes json as input & parses it to js object, promise-based

OP > returns 3 promise arrays


** ASYNC & AWAIT
syntactic sugar wrapped around promises, make it easier to work with
> introduced in ES8

EXAMPLE
function makeRequest(location) {
    return new Promise((resolve, reject) => {
        console.log(`Making request to ${location}`)

        if (location == "Google") {
            resolve(`Google says Hi`)
        } else {
            reject(`We only talk to Google`)
        }
    })
}

function processRequest(response) {
    return new Promise((resolve, reject) => {
        console.log(`Processing Response`)
        resolve(`Extra information + ${response}`)
    })
}

makeRequest('Google').then(response => {
    console.log(`Response received`)
    return processRequest(response)
}).then(processedResponse => {
    console.log(processedResponse)
}).catch(err => {
    console.log(err)
})

OP >>
Making request to Google
Response received
Processing Response
Extra information + Google says Hi


** Updating same code using async & await
AWAIT means the next code should wait till this one finishes. Use try-catch block to catch errors
async function doWork() {
    try {
        const response = await makeRequest('Google')
        console.log(`Response received`)
        const processedResponse = await processRequest(response)
        console.log(processedResponse)
    } catch(err) {
        console.log(err)
    }
}
doWork()

OP >>
Making request to Google
Response received
Processing Response
Extra information + Google says Hi



































